<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 13: Mutual Exclusion (MUTEX) | Jiming Chen</title><meta name=keywords content><meta name=description content="There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.
Atomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture13/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture13/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture13/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 13: Mutual Exclusion (MUTEX)"><meta property="og:description" content="There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.
Atomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-03-06T13:30:49-05:00"><meta property="article:modified_time" content="2025-03-06T13:30:49-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 13: Mutual Exclusion (MUTEX)"><meta name=twitter:description content="There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.
Atomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 13: Mutual Exclusion (MUTEX)","item":"https://jiming-chen.github.io/courses/cs3420/lecture13/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 13: Mutual Exclusion (MUTEX)","name":"Lecture 13: Mutual Exclusion (MUTEX)","description":"There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.\nAtomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill.\n","keywords":[],"articleBody":"There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.\nAtomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill.\nWith mutual exclusion, we would simply stop cars on the other side of the bridge. In a computer, this means we don’t want two processes to access the same resource at the same time.\nNow, consider two programs, P1 and P2. Each program has an NCS and CS section (noncritical and critical). We can interleave NCS with other code, but we can’t interleave CS1 and CS2. Also, we ensure that the two CS sections will execute quickly and not crash (since they don’t interleave with each other).\nMutual Exclusion Requirements There are some requirements we have for mutual exclusion:\nAt any moment, at most one process is inside its CS. At any moment, of all the programs trying to run their CS, at least one is guaranteed to get access in a finite amount of time. This ensures the programs make progress. At any moment, every process actively contenting to run their CS is guaranteed access in a finite amount of time. Note that fairness implies progress.\nIf we have an intersection where all four directions are stuck in the middle of the intersection and the critical section is being in the intersection, then there is neither safety nor progress nor fairness.\nDekker’s Algorithm Dekker’s algorithm eliminates livelock and deadlock, as well as being safe. We first have to indicate that we want to get into the CS by setting x = 0, then we avoid deadlock and livelock inside the while loop using a turn flag. We avoid livelock because if multiple processes are waiting, the turn flag allows one to go through.\nIt is still possible (but unlikely) that Dekker does not ensure fairness. This could happen if P1 was skipped in the scheduler and P2 had a really short NCS.\n","wordCount":"364","inLanguage":"en","datePublished":"2025-03-06T13:30:49-05:00","dateModified":"2025-03-06T13:30:49-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture13/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 13: Mutual Exclusion (MUTEX)</h1><div class=post-meta><span title='2025-03-06 13:30:49 -0500 EST'>March 6, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#mutual-exclusion-requirements>Mutual Exclusion Requirements</a></li><li><a href=#dekkers-algorithm>Dekker&rsquo;s Algorithm</a></li></ul></nav></div></details></div><div class=post-content><p>There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.</p><p>Atomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill.</p><p>With mutual exclusion, we would simply stop cars on the other side of the bridge. In a computer, this means we don&rsquo;t want two processes to access the same resource at the same time.</p><p>Now, consider two programs, <code>P1</code> and <code>P2</code>. Each program has an <code>NCS</code> and <code>CS</code> section (noncritical and critical). We can interleave <code>NCS</code> with other code, but we can&rsquo;t interleave <code>CS1</code> and <code>CS2</code>. Also, we ensure that the two <code>CS</code> sections will execute quickly and not crash (since they don&rsquo;t interleave with each other).</p><h2 id=mutual-exclusion-requirements>Mutual Exclusion Requirements<a hidden class=anchor aria-hidden=true href=#mutual-exclusion-requirements>#</a></h2><p>There are some requirements we have for mutual exclusion:</p><ul><li>At any moment, at most one process is inside its <code>CS</code>.</li><li>At any moment, of all the programs trying to run their <code>CS</code>, at least one is guaranteed to get access in a finite amount of time. This ensures the programs make progress.</li><li>At any moment, every process actively contenting to run their <code>CS</code> is guaranteed access in a finite amount of time.</li></ul><p>Note that fairness implies progress.</p><p>If we have an intersection where all four directions are stuck in the middle of the intersection and the critical section is being in the intersection, then there is neither safety nor progress nor fairness.</p><h2 id=dekkers-algorithm>Dekker&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#dekkers-algorithm>#</a></h2><p>Dekker&rsquo;s algorithm eliminates livelock and deadlock, as well as being safe. We first have to indicate that we want to get into the <code>CS</code> by setting <code>x = 0</code>, then we avoid deadlock and livelock inside the <code>while</code> loop using a <code>turn</code> flag. We avoid livelock because if multiple processes are waiting, the <code>turn</code> flag allows one to go through.</p><p>It is still possible (but unlikely) that Dekker does not ensure fairness. This could happen if <code>P1</code> was skipped in the scheduler and <code>P2</code> had a really short <code>NCS</code>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>