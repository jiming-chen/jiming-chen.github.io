<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 2: Assembly Language Overview and Intro to ARM ISA | Jiming Chen</title>
<meta name=keywords content><meta name=description content="Assembly Intro
Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.

Fig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction.
Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture02/><link crossorigin=anonymous href=/assets/css/stylesheet.862d2ab5d22734725b747026f6cbcd72cf56acbcb80e88f95d22ca71d767e619.css integrity="sha256-hi0qtdInNHJbdHAm9svNcs9WrLy4Doj5XSLKcddn5hk=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture02/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 2: Assembly Language Overview and Intro to ARM ISA"><meta property="og:description" content="Assembly Intro Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.
Fig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction. Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-01-23T13:23:22-05:00"><meta property="article:modified_time" content="2025-01-23T13:23:22-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 2: Assembly Language Overview and Intro to ARM ISA"><meta name=twitter:description content="Assembly Intro
Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.

Fig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction.
Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 2: Assembly Language Overview and Intro to ARM ISA","item":"https://jiming-chen.github.io/courses/cs3420/lecture02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 2: Assembly Language Overview and Intro to ARM ISA","name":"Lecture 2: Assembly Language Overview and Intro to ARM ISA","description":"Assembly Intro Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.\nFig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction. Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant.\n","keywords":[],"articleBody":"Assembly Intro Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.\nFig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction. Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant.\nOne can construct a programmable processor similar to one featured in ECE 2300 in years past:\nFig. 2. Simple CPU. The above processor has an ALU, program counter, and registers which the ALU works with. In most assembly languages, the destination register usually goes first:\nADD rd, rs, rt means add the value in rs and rt and put the result in rd.\nFig. 3. Example of decoding assembly into machine code. In this case, the register is 8 bits large. The processor uses the program counter to fetch instructions and runs the program. In our case, since we have a 4-bit wide opcode, we can have 16 different instructions. Additionally, as stated above, we have 8 registers to stoer data (not including PC and Z).\nWe can think of 1101 010 100 as R[dst] \u003c- R[src1] - R[src2]; Z \u003c- R[dst] == 0; PC \u003c- PC + 1, where Z is the zero flag. Instructions can also include offsets, so 1001 111111 could mean PC \u003c- Z ? PC + 1 : PC + offset.\nSo who programs in assembly? Nowadays, not many. Back when assembly was first created, it was considered high-level and big step up. In the 80’s it was big, but it has steadily declined in favor of higher level languages. Most of the time, C works fine, but sometimes, people need to do very specific things and use small amounts of assembly.\nToday, compilers are pretty good at turning high-level languages into machine code that is very optimized and error-free, which explains why people have stopped using assembly. However, sometimes, the compiler can add instructions that are not strictly necessary. This is not always bad, but if some code needs to be high-performance e.g. needs to be run a bazillion times a day in a data center, then we want less bloated code.\nWhy do we study assembly? When we program, ultimately we are manipulating the processor, so if we want a high degree of control over how we program, we should be aware of the hardware-software interface. For example, in Java we initialize variables and magically get memory, but we should understand how that happens.\nAssembly also allows us to understand how operating systems manage multiple services and interaction with I/O devices. However, one can program without operating systems, which is known as “bare-metal” embedded systems. This is good for minimizing bloat and speeding up critical code blcoks.\nWhen we talk about a specific assembly language, we are talking about an instruction set architecture (ISA). The ISA describes what the hardware can actually do; it is a contract/specification between the client of the hardware and the implementer of the hardware. Therefore, hardware engineers can change the architecture or transistor technology, resulting in different implementations, but as long as the functionality is the same, the contract is upheld.\nWith one ISA, there can be many different design choices across product families; some people might want high-performance but some might want high-efficiency. Additionally, software can be pretty difficult to implement efficiently, so hardware engineers do a lot of trickery, e.g. out-or-order execution.\nQuiz questions For SUB R2 R4, what is SA, SB, and DR? Answer: SA = 2, SB = 4, DR = 2.\nFor BNZ NEXT, what is the value of BS? Answer: BS = 3.\nAssembly Key Points Assembly is decoded into binary instructions. There are limitations because of the fact that it is decoded into binary. There are limited registers. You cannot branch too far away. You cannot have large literals. ARM Based Processors Many people are moving toward the ARM ISA. For example Apple produces their own chips with Apple Silicon, and many machine learning companies are hiring hardware engineers to make chips specifically for optimizing machine learning. In this class, we will use ARMv6-M.\nThe ARM Cortex-M architecture has a 32-bit datapath and 32-bit addressing space. Most instructions are 16-bit for compactness, but some are 32 bits. Having instructions of different sizes can be difficult to work with because the CPU has to fetch twice for the longer instructions.\nThere are M0, M0+, M3, M4, and M7 versions, but they have the same core functionality and just have additional features.\nThe M architecture is geared toward power efficiency, so it has fewer instructions and gates on the hardware level.\nFig. 4. Instructions supported by different M-series ISAs. Notice that M0 does not have division, so division has to be written in software. In this class, we will use the MKL46Z256VLL4 processor, which includes a capacitive touch interface.\nAll ARM processors have a similar register layout. There are 16 registers, 13 of which are general purpose, labeled from R0 to R15. These are registers we can use with operations like add or subtract. The highest registers (R13 to R15) are used in a specific way to implement software. For example, R15 acts as the program counter. R14 is the link register (LR), which is pretty helpful for software. R13 is the stack pointer (SP), which is also used in software, but we can also manipulate it in hardware.\nFig. 5. Register layout for ARM. Since we have a limited number of instructions, we usually only let instructions access the lower registers.\nWhen we execute software, there are two different privileges, one for user code and one for kernel code. Each of these modes has its own copy of the stack. This is what it means to have banked stack ponters. These pointers are used to store the executation contexts of the software. When we switch contexts, we assume nothing about the general purpose registers.\nThe PSR, PRIMASK, and CONTROL registers tell us about the execution modes.\nPSR is 32 bits and has three sub-registers: Application (flags), Interrupt (exception number), and Execution (thumb state, which is always 1 for us) Condition codes are what the APSR can hold. These codes are flags that say what the result of the last instruction was (N, C, Z, and V). We can suffix an instruction with “S”, e.g. SUBS if we want to update the APSR. The general instruction format for ARM is op . There may be fewer source operands or no destination register. Operands can be registers e.g. R1 or a literal e.g. #3.\nSometimes we want to branch, and we call those labels, so we can write BNE .\nR0 to R7 are “low registers” and accessible by all instructions, and R8-R12 are “high registers” and are sometimes not accessible by 16-bit instructions.\n","wordCount":"1213","inLanguage":"en","datePublished":"2025-01-23T13:23:22-05:00","dateModified":"2025-01-23T13:23:22-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture02/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li><li><a href=https://jiming-chen.github.io/piano/ title=Piano><span>Piano</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 2: Assembly Language Overview and Intro to ARM ISA</h1><div class=post-meta><span title='2025-01-23 13:23:22 -0500 EST'>January 23, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#assembly-intro>Assembly Intro</a></li><li><a href=#quiz-questions>Quiz questions</a></li><li><a href=#assembly-key-points>Assembly Key Points</a></li><li><a href=#arm-based-processors>ARM Based Processors</a></li></ul></nav></div></details></div><div class=post-content><h2 id=assembly-intro>Assembly Intro<a hidden class=anchor aria-hidden=true href=#assembly-intro>#</a></h2><p>Assembly code is a slightly more readable version of machine code. Machine code is a list of binary instructions that are executed by the processor. In programming languages, keywords, braces, etc. make programs understandable by humans and easy to use. Compilers take that code and convert it into assembly code. Then, each line of assembly is converted in machine code.</p><img src=/courses/cs3420/lecture02/layers.png alt="Code translation" width=80% class=center><figcaption>Fig. 1. One line of C code often corresponds to three or four lines of assembly code. Assembly to machine is just decoding, which is a very thin layer of abstraction.</figcaption><p>Why are keywords in assembly very short (two or three letters)? Back when programs were written on punched cards, there was a margin on the cards, and people wrote short descriptions for what the holes (binary representation) meant.</p><p>One can construct a programmable processor similar to one featured in ECE 2300 in years past:</p><img src=/courses/cs3420/lecture02/cpu.png alt="Simple CPU" width=80% class=center><figcaption>Fig. 2. Simple CPU.</figcaption><p>The above processor has an ALU, program counter, and registers which the ALU works with. In most assembly languages, the destination register usually goes first:</p><blockquote><p><code>ADD rd, rs, rt</code> means add the value in <code>rs</code> and <code>rt</code> and put the result in <code>rd</code>.</p></blockquote><img src=/courses/cs3420/lecture02/decode.png alt=Decoding width=80% class=center><figcaption>Fig. 3. Example of decoding assembly into machine code. In this case, the register is 8 bits large.</figcaption><p>The processor uses the program counter to fetch instructions and runs the program. In our case, since we have a 4-bit wide opcode, we can have 16 different instructions. Additionally, as stated above, we have 8 registers to stoer data (not including PC and Z).</p><p>We can think of <code>1101 010 100</code> as <code>R[dst] &lt;- R[src1] - R[src2]; Z &lt;- R[dst] == 0; PC &lt;- PC + 1</code>, where <code>Z</code> is the zero flag. Instructions can also include offsets, so <code>1001 111111</code> could mean <code>PC &lt;- Z ? PC + 1 : PC + offset</code>.</p><p>So who programs in assembly? Nowadays, not many. Back when assembly was first created, it was considered high-level and big step up. In the 80&rsquo;s it was big, but it has steadily declined in favor of higher level languages. Most of the time, C works fine, but sometimes, people need to do very specific things and use small amounts of assembly.</p><p>Today, compilers are pretty good at turning high-level languages into machine code that is very optimized and error-free, which explains why people have stopped using assembly. However, sometimes, the compiler can add instructions that are not strictly necessary. This is not always bad, but if some code needs to be high-performance e.g. needs to be run a bazillion times a day in a data center, then we want less bloated code.</p><p>Why do we study assembly? When we program, ultimately we are manipulating the processor, so if we want a high degree of control over how we program, we should be aware of the hardware-software interface. For example, in Java we initialize variables and magically get memory, but we should understand how that happens.</p><p>Assembly also allows us to understand how operating systems manage multiple services and interaction with I/O devices. However, one can program without operating systems, which is known as &ldquo;bare-metal&rdquo; embedded systems. This is good for minimizing bloat and speeding up critical code blcoks.</p><p>When we talk about a specific assembly language, we are talking about an <strong>instruction set architecture (ISA)</strong>. The ISA describes what the hardware can actually do; it is a contract/specification between the client of the hardware and the implementer of the hardware. Therefore, hardware engineers can change the architecture or transistor technology, resulting in different implementations, but as long as the functionality is the same, the contract is upheld.</p><p>With one ISA, there can be many different design choices across product families; some people might want high-performance but some might want high-efficiency. Additionally, software can be pretty difficult to implement efficiently, so hardware engineers do a lot of trickery, e.g. out-or-order execution.</p><h2 id=quiz-questions>Quiz questions<a hidden class=anchor aria-hidden=true href=#quiz-questions>#</a></h2><ol><li>For <code>SUB R2 R4</code>, what is <code>SA</code>, <code>SB</code>, and <code>DR</code>?</li></ol><p>Answer: <code>SA = 2</code>, <code>SB = 4</code>, <code>DR = 2</code>.</p><ol start=2><li>For <code>BNZ NEXT</code>, what is the value of <code>BS</code>?</li></ol><p>Answer: <code>BS = 3</code>.</p><h2 id=assembly-key-points>Assembly Key Points<a hidden class=anchor aria-hidden=true href=#assembly-key-points>#</a></h2><ul><li>Assembly is decoded into binary instructions.</li><li>There are limitations because of the fact that it is decoded into binary.<ul><li>There are limited registers.</li><li>You cannot branch too far away.</li><li>You cannot have large literals.</li></ul></li></ul><h2 id=arm-based-processors>ARM Based Processors<a hidden class=anchor aria-hidden=true href=#arm-based-processors>#</a></h2><p>Many people are moving toward the ARM ISA. For example Apple produces their own chips with Apple Silicon, and many machine learning companies are hiring hardware engineers to make chips specifically for optimizing machine learning. In this class, we will use <strong>ARMv6-M</strong>.</p><p>The ARM Cortex-M architecture has a 32-bit datapath and 32-bit addressing space. Most instructions are 16-bit for compactness, but some are 32 bits. Having instructions of different sizes can be difficult to work with because the CPU has to fetch twice for the longer instructions.</p><p>There are M0, M0+, M3, M4, and M7 versions, but they have the same core functionality and just have additional features.</p><p>The M architecture is geared toward power efficiency, so it has fewer instructions and gates on the hardware level.</p><img src=/courses/cs3420/lecture02/arm.png alt="Simple CPU" width=80% class=center><figcaption>Fig. 4. Instructions supported by different M-series ISAs. Notice that M0 does not have division, so division has to be written in software.</figcaption><p>In this class, we will use the <a href=https://www.nxp.com/part/MKL46Z256VLL4 rel=noopener target=_blank>MKL46Z256VLL4</a> processor, which includes a capacitive touch interface.</p><p>All ARM processors have a similar register layout. There are 16 registers, 13 of which are general purpose, labeled from R0 to R15. These are registers we can use with operations like add or subtract. The highest registers (R13 to R15) are used in a specific way to implement software. For example, R15 acts as the program counter. R14 is the link register (LR), which is pretty helpful for software. R13 is the stack pointer (SP), which is also used in software, but we can also manipulate it in hardware.</p><img src=/courses/cs3420/lecture02/registers.png alt="Register layout" width=80% class=center><figcaption>Fig. 5. Register layout for ARM.</figcaption><p>Since we have a limited number of instructions, we usually only let instructions access the lower registers.</p><p>When we execute software, there are two different privileges, one for user code and one for kernel code. Each of these modes has its own copy of the stack. This is what it means to have <strong>banked stack ponters</strong>. These pointers are used to store the executation contexts of the software. When we switch contexts, we assume nothing about the general purpose registers.</p><p>The PSR, PRIMASK, and CONTROL registers tell us about the execution modes.</p><ul><li>PSR is 32 bits and has three sub-registers: Application (flags), Interrupt (exception number), and Execution (thumb state, which is always 1 for us)<ul><li>Condition codes are what the APSR can hold. These codes are flags that say what the result of the last instruction was (N, C, Z, and V). We can suffix an instruction with &ldquo;S&rdquo;, e.g. <code>SUBS</code> if we want to update the APSR.</li></ul></li></ul><p>The general instruction format for ARM is <code>op &lt;dst> &lt;src1> &lt;src2></code>. There may be fewer source operands or no destination register. Operands can be registers e.g. <code>R1</code> or a literal e.g. <code>#3</code>.</p><p>Sometimes we want to branch, and we call those labels, so we can write <code>BNE &lt;label></code>.</p><p>R0 to R7 are &ldquo;low registers&rdquo; and accessible by all instructions, and R8-R12 are &ldquo;high registers&rdquo; and are sometimes not accessible by 16-bit instructions.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>