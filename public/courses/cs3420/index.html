<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CS 3420: Embedded Systems | Jiming Chen</title>
<meta name=keywords content><meta name=description content="Taken SP25. Taught by Nils Napp."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/><link crossorigin=anonymous href=/assets/css/stylesheet.862d2ab5d22734725b747026f6cbcd72cf56acbcb80e88f95d22ca71d767e619.css integrity="sha256-hi0qtdInNHJbdHAm9svNcs9WrLy4Doj5XSLKcddn5hk=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jiming-chen.github.io/courses/cs3420/index.xml><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="CS 3420: Embedded Systems"><meta property="og:description" content="Taken SP25. Taught by Nils Napp."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="CS 3420: Embedded Systems"><meta name=twitter:description content="Jiming Chen's Personal Website"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>CS 3420: Embedded Systems
<a href=/courses/cs3420/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><div class=post-content><p>Taken SP25. Taught by Nils Napp.</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 16: Readers and Writers</h2></header><div class=entry-content><p>Concurrency Recap In the past, we have been discussing concurrency, whether that be multiple programs on the same CPU or multiple processors accessing the same memory. We studied mutual exclusion, specifically using locks (which ensure that no two programs enter their critical sections at the same time).
We studied how atomicity ensures only one programming is running at once, but that is a very strong requirement. Concurrency means only one critical section is running at any given time though we can still have other interleaving.
...</p></div><footer class=entry-footer><span title='2025-03-18 13:30:42 -0400 EDT'>March 18, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 16: Readers and Writers" href=https://jiming-chen.github.io/courses/cs3420/lecture16/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 14: Locks</h2></header><div class=entry-content><p>Dekker’s algorithm correctly implements mutual exclusion. However, this is a little bit convoluted. Additionally, each process must know about the other process, which violates modularity for programming. Therefore, we create a new abstraction: locks.
Say we have a lock called l. Then, we can acquire the lock (lock(l)) or release the lock (unlock(l)).
Then, a program consists of the NCS then a lock then CS then unlock.
Note that using a single lock for different resources that need to be protected with a lock can be inefficient. Therefore, if multiple resources can change x, we can assign a lock to x.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:32:29 -0400 EDT'>March 11, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 14: Locks" href=https://jiming-chen.github.io/courses/cs3420/lecture14/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 13: Mutual Exclusion (MUTEX)</h2></header><div class=entry-content><p>There are two ways of thinking about concurrency control: atomic actions vs. mutual exclusion. The latter is more fine-grained.
Atomicity means that nothing else can happen at the same time. Imagine we had a one-lane bridge. If you were trying to cross the bridge, being atomic would mean stopping all cars in Ithaca so that you can safely cross. This is a very strong statement about the system and is overkill.
...</p></div><footer class=entry-footer><span title='2025-03-06 13:30:49 -0500 EST'>March 6, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 13: Mutual Exclusion (MUTEX)" href=https://jiming-chen.github.io/courses/cs3420/lecture13/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 12: Concurrency</h2></header><div class=entry-content><p>Imagine a bitstream controlling some LEDs. If you have an interrupt in the middle of a bitstream (not aligned with the 24 bits that encode the color), then things will go wrong.
If we wanted blue light to travel down an LED strip faster than a red light, instead of using one loop, we should use two. But if we run two loops together, we can get weird bugs.
If we want two pieces of code to interact in the same memory space, we call them threads (as opposed to processes). This also means we have to be more careful.
...</p></div><footer class=entry-footer><span title='2025-03-04 13:50:07 -0500 EST'>March 4, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 12: Concurrency" href=https://jiming-chen.github.io/courses/cs3420/lecture12/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 11: Time Sharing</h2></header><div class=entry-content><p>Context Switching If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.
In order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.
What does the CPU need to execute a program the same way at two different times? We would need at least
...</p></div><footer class=entry-footer><span title='2025-02-27 13:30:20 -0500 EST'>February 27, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 11: Time Sharing" href=https://jiming-chen.github.io/courses/cs3420/lecture11/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 10: More Communication Protocols</h2></header><div class=entry-content><p>I2C Bus In CAN, we worried about clock synchronization. This is not an issue with I2C because I2C has separate data (SDA) and clock (SCL) lines. The data set set when SCL is low. Conventionally, when SCL is high, the data should not change.
The master signals the start of a message by changing SDA from high to low while SCL is high. Conversely, a stop is indicated by changing SDA from low to high while SCL is high.
...</p></div><footer class=entry-footer><span title='2025-02-25 13:29:47 -0500 EST'>February 25, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 10: More Communication Protocols" href=https://jiming-chen.github.io/courses/cs3420/lecture10/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 9: Communication Protocols</h2></header><div class=entry-content><p>ISR Recap Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).
There are two types of interrupts:
Non-maskable interrupts cannot be disabled, such as resets or HardFaults. Maskable interrupts are the most common. These are controlled by the user and can be selectively activated. Additionally, recall that in our case, we need to enable interrupts, which requires several things:
...</p></div><footer class=entry-footer><span title='2025-02-20 13:37:25 -0500 EST'>February 20, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 9: Communication Protocols" href=https://jiming-chen.github.io/courses/cs3420/lecture09/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 8: Interrupts and Exceptions</h2></header><div class=entry-content><p>Let’s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.
One way to know if a button pressed is polling, where a loop continually reads the GPIO port.
Another option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code.
...</p></div><footer class=entry-footer><span title='2025-02-13 13:33:09 -0500 EST'>February 13, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 8: Interrupts and Exceptions" href=https://jiming-chen.github.io/courses/cs3420/lecture08/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 7: Peripherals and GPIO</h2></header><div class=entry-content><p>So far, we have used the OpenSDA USB which connects to an ARM debugging chip which is serially connected to the KL46Z256. This can interface with the red LED. We can also interface with a segment LCD, magnetometer, and accelerometer.
The chip has a lot of pins surrounding it, and it is isometric, so we can match the dot on the diagram with a dimple on the chip. Note that some pins are labeled similarly, e.g. PT means port.
...</p></div><footer class=entry-footer><span title='2025-02-11 13:29:15 -0500 EST'>February 11, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 7: Peripherals and GPIO" href=https://jiming-chen.github.io/courses/cs3420/lecture07/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lecture 6: Function Calls and Program Memory Layout</h2></header><div class=entry-content><p>Function Calls If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.
We can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can’t do POP LR because LR is not a lower register.
PUSH Encoding With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions.
...</p></div><footer class=entry-footer><span title='2025-02-06 13:27:42 -0500 EST'>February 6, 2025</span>&nbsp;·&nbsp;Jiming Chen</footer><a class=entry-link aria-label="post link to Lecture 6: Function Calls and Program Memory Layout" href=https://jiming-chen.github.io/courses/cs3420/lecture06/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://jiming-chen.github.io/courses/cs3420/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>