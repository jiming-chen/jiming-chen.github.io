<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 4: ARM Memory Organization | Jiming Chen</title><meta name=keywords content><meta name=description content="ARM Memory Map
All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).

Fig. 1. Memory map for Cortex M0+.
The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture04/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture04/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture04/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 4: ARM Memory Organization"><meta property="og:description" content="ARM Memory Map All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).
Fig. 1. Memory map for Cortex M0+. The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-01-30T13:31:55-05:00"><meta property="article:modified_time" content="2025-01-30T13:31:55-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 4: ARM Memory Organization"><meta name=twitter:description content="ARM Memory Map
All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).

Fig. 1. Memory map for Cortex M0+.
The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 4: ARM Memory Organization","item":"https://jiming-chen.github.io/courses/cs3420/lecture04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 4: ARM Memory Organization","name":"Lecture 4: ARM Memory Organization","description":"ARM Memory Map All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).\nFig. 1. Memory map for Cortex M0+. The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains.\n","keywords":[],"articleBody":"ARM Memory Map All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).\nFig. 1. Memory map for Cortex M0+. The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains.\nOur NXP ARM cores have a weird convention where they put one quarter of the 32 kB SRM in the code space and the rest in the SRAM code space. The reason they do this is because they want to prevent execution of some code. This is also done because the memory bus may be physically faster for the lower memory addresses.\nMemory Organization A byte is 8 bits, and a word is 32 bits. Word and half words are aligned, so for a 4-byte word, the base address is divisible by 4, and its value is stored in the location as well as the next three bytes.\nEndianness is the order of bytes in a larger data type. Little endian (used in our processors) says that the least significant byte has the smallest address. When using big endian, the smallest memory address has the most significant byte, so the first byte we see is the most significant byte. This is used a lot in networking and transmitting serial data.\nEvery word is connected to the memory bus, but when a specific word is addressed (by its starting byte), the whole word is activated in sent through the bus. However, we can also read one byte, but of the four bytes we receive in the bus, we have to choose the right one. The memory does this for us.\nFig. 2. Diagram of memory addresses arranged in lines. What if we want to read one word that is not word-aligned? In order to do this, we have to access the memory twice and extract the correct bytes to be assembled into the non-aligned word.\nQuestion: If we have four consecutive blocks that say 0xde, 0xad, 0xbe, and 0xef from highest address to lowest address, what data values are not possible between 0xdeadbeef, 0xadbe, 0xbeef, and 0xefbe?\nAnswer: 0xadbe is not half word aligned, and 0xefbe is big endian, so they are not allowed.\nLoad and Store Operations ARM is a load-store architecture, meaning all the operations it does are on the registers. Therefore, if we want to interact with the memory, we need to move the memory to and from the registers. In some other systems, you can operate on memory without bringing the data to the CPU, but that architecture is way more difficult to operate. In this class, we do what is easy, but the tradeoff is that it can be slow to do simple things like check a value in memory.\nLoad instructions look like LDR , . Store instructions look like STR , . If the data is not 32 bits, you will get an error. You can also load half-word or byte data:\nFig. 3. Table showing instructions for loading bytes nad half words. There are also versions of these instructions that sign extend the data.\nAddressing Modes Sometimes we want to calculate the address of something. Then, we can write [, ] as an address in an instruction. We can also refer to a label as =LABEL, and the assembler will calculate the address.\nSome examples of addressing modes in instructions are\nLDR R2, [R3, #8] LDR R2, [R3, R4] LDR R2, =SOME_LABEL Timing Different ARM instructions take different amounts of time to execute:\nFig. 4. Table showing timing of instructions. Notice that most instructions take only 1 cycle, but manipulating the program counter takes 2 cycles. This is because we have to wait for our 2-stage pipeline to finish and fetch and decode the next instruction.\nPseudo-Instructions Sometimes, we use an instruction that doesn’t actually exist, but it allows functionality. For example, a NOP instruction (which does nothing but delays for one clock cycle) is implemented as a MOV where a register is moved to the same location.\nSome other examples are below.\nMOVS , is implemented as ADDS , , #0. LDR , =LABEL is implemented as LDR , [PC, #offset]. Some C Data Structures An array is a data structure consisting of a collection of elements which are contiguous in memory. We can declare an array of 3 integers by saying int x[3]. Then, since integers are 32 bits, we can have one word corresponding to each element of the array. Indexing based on 0 makes accessing addresses easily. We simply add that many words to the address of the array, which is the address of the first element.\nStrings in C are stored as arrays of chars terminated by the nul character \\0. A char is 1 byte long, so a 5 letter string is 6 bytes long. Since strings are just binary data instead of objects with fields like length, the nul character allows us to know where the string ends.\n","wordCount":"851","inLanguage":"en","datePublished":"2025-01-30T13:31:55-05:00","dateModified":"2025-01-30T13:31:55-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture04/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 4: ARM Memory Organization</h1><div class=post-meta><span title='2025-01-30 13:31:55 -0500 EST'>January 30, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#arm-memory-map>ARM Memory Map</a></li><li><a href=#memory-organization>Memory Organization</a></li><li><a href=#load-and-store-operations>Load and Store Operations</a><ul><li><a href=#addressing-modes>Addressing Modes</a></li></ul></li><li><a href=#timing>Timing</a></li><li><a href=#pseudo-instructions>Pseudo-Instructions</a></li><li><a href=#some-c-data-structures>Some C Data Structures</a></li></ul></nav></div></details></div><div class=post-content><h2 id=arm-memory-map>ARM Memory Map<a hidden class=anchor aria-hidden=true href=#arm-memory-map>#</a></h2><p>All versions of ARM have the same memory encoding which makes compatibility easy. Each memory address is 32 bits, which means we can have 4 gigabytes of data (because each memory block holds 1 byte).</p><img src=/courses/cs3420/lecture04/map.png alt="Cortex M0+ Memory Map" width=80% class=center><figcaption>Fig. 1. Memory map for Cortex M0+.</figcaption><p>The bottom 500 megabytes of memory holds the code, some of which non-volatile (256 kB), meaning if the system reboots, the memory remains.</p><p>Our NXP ARM cores have a weird convention where they put one quarter of the 32 kB SRM in the code space and the rest in the SRAM code space. The reason they do this is because they want to prevent execution of some code. This is also done because the memory bus may be physically faster for the lower memory addresses.</p><h2 id=memory-organization>Memory Organization<a hidden class=anchor aria-hidden=true href=#memory-organization>#</a></h2><p>A byte is 8 bits, and a word is 32 bits. Word and half words are aligned, so for a 4-byte word, the base address is divisible by 4, and its value is stored in the location as well as the next three bytes.</p><p>Endianness is the order of bytes in a larger data type. <strong>Little endian</strong> (used in our processors) says that the least significant byte has the smallest address. When using <strong>big endian</strong>, the smallest memory address has the most significant byte, so the first byte we see is the most significant byte. This is used a lot in networking and transmitting serial data.</p><p>Every word is connected to the memory bus, but when a specific word is addressed (by its starting byte), the whole word is activated in sent through the bus. However, we can also read one byte, but of the four bytes we receive in the bus, we have to choose the right one. The memory does this for us.</p><img src=/courses/cs3420/lecture04/lines.png alt="Memory Lines" width=80% class=center><figcaption>Fig. 2. Diagram of memory addresses arranged in lines.</figcaption><p>What if we want to read one word that is not word-aligned? In order to do this, we have to access the memory twice and extract the correct bytes to be assembled into the non-aligned word.</p><blockquote><p><strong>Question</strong>: If we have four consecutive blocks that say <code>0xde</code>, <code>0xad</code>, <code>0xbe</code>, and <code>0xef</code> from highest address to lowest address, what data values are not possible between <code>0xdeadbeef</code>, <code>0xadbe</code>, <code>0xbeef</code>, and <code>0xefbe</code>?</p></blockquote><blockquote><p><strong>Answer</strong>: <code>0xadbe</code> is not half word aligned, and <code>0xefbe</code> is big endian, so they are not allowed.</p></blockquote><h2 id=load-and-store-operations>Load and Store Operations<a hidden class=anchor aria-hidden=true href=#load-and-store-operations>#</a></h2><p>ARM is a load-store architecture, meaning all the operations it does are on the registers. Therefore, if we want to interact with the memory, we need to move the memory to and from the registers. In some other systems, you can operate on memory without bringing the data to the CPU, but that architecture is way more difficult to operate. In this class, we do what is easy, but the tradeoff is that it can be slow to do simple things like check a value in memory.</p><ul><li>Load instructions look like <code>LDR &lt;Rt>, &lt;address></code>.</li><li>Store instructions look like <code>STR &lt;Rt>, &lt;address></code>. If the data is not 32 bits, you will get an error.</li></ul><p>You can also load half-word or byte data:</p><img src=/courses/cs3420/lecture04/load.png alt="Loading Byte and Half-Word Instructions" width=90% class=center><figcaption>Fig. 3. Table showing instructions for loading bytes nad half words.</figcaption><p>There are also versions of these instructions that sign extend the data.</p><h3 id=addressing-modes>Addressing Modes<a hidden class=anchor aria-hidden=true href=#addressing-modes>#</a></h3><p>Sometimes we want to calculate the address of something. Then, we can write <code>[&lt;Rn>, &lt;offset>]</code> as an address in an instruction. We can also refer to a label as <code>=LABEL</code>, and the assembler will calculate the address.</p><p>Some examples of addressing modes in instructions are</p><ul><li><code>LDR R2, [R3, #8]</code></li><li><code>LDR R2, [R3, R4]</code></li><li><code>LDR R2, =SOME_LABEL</code></li></ul><h2 id=timing>Timing<a hidden class=anchor aria-hidden=true href=#timing>#</a></h2><p>Different ARM instructions take different amounts of time to execute:</p><img src=/courses/cs3420/lecture04/timing.png alt="Timing of Instructions" width=90% class=center><figcaption>Fig. 4. Table showing timing of instructions.</figcaption><p>Notice that most instructions take only 1 cycle, but manipulating the program counter takes 2 cycles. This is because we have to wait for our 2-stage pipeline to finish and fetch and decode the next instruction.</p><h2 id=pseudo-instructions>Pseudo-Instructions<a hidden class=anchor aria-hidden=true href=#pseudo-instructions>#</a></h2><p>Sometimes, we use an instruction that doesn&rsquo;t actually exist, but it allows functionality. For example, a <code>NOP</code> instruction (which does nothing but delays for one clock cycle) is implemented as a <code>MOV</code> where a register is moved to the same location.</p><p>Some other examples are below.</p><ul><li><code>MOVS &lt;Rt>, &lt;Rn></code> is implemented as <code>ADDS &lt;Rt>, &lt;Rn>, #0</code>.</li><li><code>LDR &lt;Rt>, =LABEL</code> is implemented as <code>LDR &lt;Rt>, [PC, #offset]</code>.</li></ul><h2 id=some-c-data-structures>Some C Data Structures<a hidden class=anchor aria-hidden=true href=#some-c-data-structures>#</a></h2><p>An <strong>array</strong> is a data structure consisting of a collection of elements which are contiguous in memory. We can declare an array of 3 integers by saying <code>int x[3]</code>. Then, since integers are 32 bits, we can have one word corresponding to each element of the array. Indexing based on 0 makes accessing addresses easily. We simply add that many words to the address of the array, which is the address of the first element.</p><p><strong>Strings</strong> in C are stored as arrays of <code>char</code>s terminated by the nul character <code>\0</code>. A char is 1 byte long, so a 5 letter string is 6 bytes long. Since strings are just binary data instead of objects with fields like length, the nul character allows us to know where the string ends.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>