<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 3: Some ARM Instructions | Jiming Chen</title><meta name=keywords content><meta name=description content="ARM ISA Recap
Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.
Some examples of instructions are

MOV 47, #4
SUB R2, R2, R4 which is the same as SUB R2, R4
ADDS R2, R2, #3 which has the S suffix and updates the status flag


Question: Which instruction(s) are not allowed to be compiled?"><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture03/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture03/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 3: Some ARM Instructions"><meta property="og:description" content="ARM ISA Recap Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.
Some examples of instructions are
MOV 47, #4 SUB R2, R2, R4 which is the same as SUB R2, R4 ADDS R2, R2, #3 which has the S suffix and updates the status flag Question: Which instruction(s) are not allowed to be compiled?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-01-28T13:27:56-05:00"><meta property="article:modified_time" content="2025-01-28T13:27:56-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 3: Some ARM Instructions"><meta name=twitter:description content="ARM ISA Recap
Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.
Some examples of instructions are

MOV 47, #4
SUB R2, R2, R4 which is the same as SUB R2, R4
ADDS R2, R2, #3 which has the S suffix and updates the status flag


Question: Which instruction(s) are not allowed to be compiled?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 3: Some ARM Instructions","item":"https://jiming-chen.github.io/courses/cs3420/lecture03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 3: Some ARM Instructions","name":"Lecture 3: Some ARM Instructions","description":"ARM ISA Recap Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.\nSome examples of instructions are\nMOV 47, #4 SUB R2, R2, R4 which is the same as SUB R2, R4 ADDS R2, R2, #3 which has the S suffix and updates the status flag Question: Which instruction(s) are not allowed to be compiled?\n","keywords":[],"articleBody":"ARM ISA Recap Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.\nSome examples of instructions are\nMOV 47, #4 SUB R2, R2, R4 which is the same as SUB R2, R4 ADDS R2, R2, #3 which has the S suffix and updates the status flag Question: Which instruction(s) are not allowed to be compiled?\nSUB R2, R3 SUB R5, R9 SUB SP, #4 Answer: The second instruction is not legal because it accesses a higher register. The third option is legal because soetimes we want to add or subtract literals to the stack pointer.\nMore ARM In this ISA, a prefix of 0x1D to 0x1F means a 32-bit instruction. Otherwise, the instruction has 16 bits.\nSUB (immediate) There are two encodings for immediate subtraction. Both have zero-extended immediate values.\nT1 has a 3-bit immediate value. T2 assumes src1 and dst are the same, which frees up 3 bits. This allows an 8-bit literal (there is other space freed up). Fig. 1. SUB (immediate) encodings. Question: What is the largest number #N you can use in the instruction SUBS R5, R3, #N?\nAnswer: 7. The destination is distinct from the source, so we know this is the T2 encoding, so we have 3 bits for the literal.\nQuestion: What is the largest number #N you can use in the instruction SUBS R5, #N?\nAnswer: 255. The destination is distinct from the source, so we know this is the T2 encoding, so we have 8 bits for the literal.\nQuestion: Can you substract negative literals? E.g. SUBS R3, #-3.\nAnswer: No. The immediate value is zero-extended, not sign-extended.\nSUB (register) T1 has two source registers and destination register. Always runs SUBS. Normally, the assembler changes SUB to SUBS automatically, but you can also allow it to be nitpicky and throw an error. Fig. 2. SUB (register) encodings. SUB (SP = R13) T1 has the stack pointer as a destination of a literal subtraction. The stack pointer is not encoded in the instruction because it is hard-coded into the opcode. This allows a 7-bit immediate value which is zero-extended 2 bits to the left (multiply by 4) since the number in the stack pointer must be a multiple of 4. The assembler ensures the immediate value is a multiple of 4 then divides it by 4 when it creates the instruction. Fig. 3. SUB (SP=13) encodings. MOV (immediate) T1 moves an 8-bit immediate value into the destination register. MOV (register) T1 moves Rm (4 bits) into Rd (3 bits) T2 sets flags so can only allocate 3 bits to Rm (low registers). Sometimes we just need to move stuff around, which is when we would use the T1 encoding.\nMore Instruction Stuff You can assume that add and move instructions always set status flags (S suffix).\nInstructions are expressed in hexadecimal, so a 16-bit instructino would look like 0x2202. (the 0x just means the number is hexadecimal)\nMost instructions take 1 cycle, except branch, load, and register manipulation instructions, which take 2 cycles. Also, multiply instructions can take a weird number of cycles. This assumes we have a 2-stage pipeline, though, and branch instructions will take longer with larger pipelines.\nBranches In some other assembly languages, branches are referred to as jumps.\nWe can use an unconditional branch (B) or a conditional branch (BXX where the XX suffix tells which condition causes the branch.)\nFig. 4. Branch condition table. Whereas conditional branches limit you to about 256 B of branch, unconditional allows you to branch about 2 kB.\nThe assembler often computes offset for us, so we can use labels instead, e.g. “Loop.”\nWe use conditional branching much more often, and it is encoded as follows:\nThe T1 encoding allows an additional condition in the instruction but has a smaller immediate value (8 bits). the T2 encoding has a larger immediate value (11 bits). This is important because we often want to branch far away. For both encodings, the assembler divides the immediate value by 2 in the instruction, and this gets shifted left by 1 bit when executed.\nFig. 4. Conditional branch encodings. Sometimes, we want to move really really far away. This is when a 32-bit instruction would be useful. The branch \u0026 link does exactly this.\nFig. 4. Branch \u0026 link encodings. This 32-bit instruction is actually two instructions, but bits 15 to 11 of the first instruction are 11110, which is 0x1E. Recall that this tells the processor that this instruction is 32 bits.\n","wordCount":"769","inLanguage":"en","datePublished":"2025-01-28T13:27:56-05:00","dateModified":"2025-01-28T13:27:56-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture03/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 3: Some ARM Instructions</h1><div class=post-meta><span title='2025-01-28 13:27:56 -0500 EST'>January 28, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#arm-isa-recap>ARM ISA Recap</a></li><li><a href=#more-arm>More ARM</a><ul><li><a href=#sub-immediate>SUB (immediate)</a></li><li><a href=#sub-register>SUB (register)</a></li><li><a href=#sub-sp--r13>SUB (SP = R13)</a></li><li><a href=#mov-immediate>MOV (immediate)</a></li><li><a href=#mov-register>MOV (register)</a></li></ul></li><li><a href=#more-instruction-stuff>More Instruction Stuff</a><ul><li><a href=#branches>Branches</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=arm-isa-recap>ARM ISA Recap<a hidden class=anchor aria-hidden=true href=#arm-isa-recap>#</a></h2><p>Recall that the ARM ISA has most instructions as 16 bits; since we have resource constraints and everything costs money, we want to fit as many instructions on the chip as possible.</p><p>Some examples of instructions are</p><ul><li><code>MOV 47, #4</code></li><li><code>SUB R2, R2, R4</code> which is the same as <code>SUB R2, R4</code></li><li><code>ADDS R2, R2, #3</code> which has the <code>S</code> suffix and updates the status flag</li></ul><blockquote><p><strong>Question</strong>: Which instruction(s) are not allowed to be compiled?</p><ul><li><code>SUB R2, R3</code></li><li><code>SUB R5, R9</code></li><li><code>SUB SP, #4</code></li></ul></blockquote><blockquote><p><strong>Answer</strong>: The second instruction is not legal because it accesses a higher register. The third option is legal because soetimes we want to add or subtract literals to the stack pointer.</p></blockquote><h2 id=more-arm>More ARM<a hidden class=anchor aria-hidden=true href=#more-arm>#</a></h2><p>In this ISA, a prefix of 0x1D to 0x1F means a 32-bit instruction. Otherwise, the instruction has 16 bits.</p><h3 id=sub-immediate>SUB (immediate)<a hidden class=anchor aria-hidden=true href=#sub-immediate>#</a></h3><p>There are two encodings for immediate subtraction. Both have zero-extended immediate values.</p><ul><li>T1 has a 3-bit immediate value.</li><li>T2 assumes <code>src1</code> and <code>dst</code> are the same, which frees up 3 bits. This allows an 8-bit literal (there is other space freed up).</li></ul><img src=/courses/cs3420/lecture03/sub_imm.png alt="SUB (immediate) encodings" width=80% class=center><figcaption>Fig. 1. SUB (immediate) encodings.</figcaption><blockquote><p><strong>Question</strong>: What is the largest number <code>#N</code> you can use in the instruction <code>SUBS R5, R3, #N</code>?</p></blockquote><blockquote><p><strong>Answer</strong>: 7. The destination is distinct from the source, so we know this is the T2 encoding, so we have 3 bits for the literal.</p></blockquote><blockquote><p><strong>Question</strong>: What is the largest number <code>#N</code> you can use in the instruction <code>SUBS R5, #N</code>?</p></blockquote><blockquote><p><strong>Answer</strong>: 255. The destination is distinct from the source, so we know this is the T2 encoding, so we have 8 bits for the literal.</p></blockquote><blockquote><p><strong>Question</strong>: Can you substract negative literals? E.g. <code>SUBS R3, #-3</code>.</p></blockquote><blockquote><p><strong>Answer</strong>: No. The immediate value is zero-extended, not sign-extended.</p></blockquote><h3 id=sub-register>SUB (register)<a hidden class=anchor aria-hidden=true href=#sub-register>#</a></h3><ul><li>T1 has two source registers and destination register. Always runs <code>SUBS</code>. Normally, the assembler changes <code>SUB</code> to <code>SUBS</code> automatically, but you can also allow it to be nitpicky and throw an error.</li></ul><img src=/courses/cs3420/lecture03/sub_reg.png alt="SUB (register) encodings" width=80% class=center><figcaption>Fig. 2. SUB (register) encodings.</figcaption><h3 id=sub-sp--r13>SUB (SP = R13)<a hidden class=anchor aria-hidden=true href=#sub-sp--r13>#</a></h3><ul><li>T1 has the stack pointer as a destination of a literal subtraction. The stack pointer is not encoded in the instruction because it is hard-coded into the opcode. This allows a 7-bit immediate value which is zero-extended 2 bits to the left (multiply by 4) since the number in the stack pointer must be a multiple of 4. The assembler ensures the immediate value is a multiple of 4 then divides it by 4 when it creates the instruction.</li></ul><img src=/courses/cs3420/lecture03/sub_sp.png alt="SUB (SP=13) encodings" width=80% class=center><figcaption>Fig. 3. SUB (SP=13) encodings.</figcaption><h3 id=mov-immediate>MOV (immediate)<a hidden class=anchor aria-hidden=true href=#mov-immediate>#</a></h3><ul><li>T1 moves an 8-bit immediate value into the destination register.</li></ul><h3 id=mov-register>MOV (register)<a hidden class=anchor aria-hidden=true href=#mov-register>#</a></h3><ul><li>T1 moves <code>Rm</code> (4 bits) into <code>Rd</code> (3 bits)</li><li>T2 sets flags so can only allocate 3 bits to <code>Rm</code> (low registers).</li></ul><p>Sometimes we just need to move stuff around, which is when we would use the T1 encoding.</p><h2 id=more-instruction-stuff>More Instruction Stuff<a hidden class=anchor aria-hidden=true href=#more-instruction-stuff>#</a></h2><p>You can assume that add and move instructions always set status flags (<code>S</code> suffix).</p><p>Instructions are expressed in hexadecimal, so a 16-bit instructino would look like <code>0x2202</code>. (the <code>0x</code> just means the number is hexadecimal)</p><p>Most instructions take 1 cycle, except branch, load, and register manipulation instructions, which take 2 cycles. Also, multiply instructions can take a weird number of cycles. This assumes we have a 2-stage pipeline, though, and branch instructions will take longer with larger pipelines.</p><h3 id=branches>Branches<a hidden class=anchor aria-hidden=true href=#branches>#</a></h3><p>In some other assembly languages, branches are referred to as jumps.</p><p>We can use an unconditional branch (<code>B</code>) or a conditional branch (<code>BXX</code> where the <code>XX</code> suffix tells which condition causes the branch.)</p><img src=/courses/cs3420/lecture03/branch.png alt="Branch conditions" width=80% class=center><figcaption>Fig. 4. Branch condition table.</figcaption><p>Whereas conditional branches limit you to about 256 B of branch, unconditional allows you to branch about 2 kB.</p><p>The assembler often computes offset for us, so we can use labels instead, e.g. &ldquo;Loop.&rdquo;</p><p>We use conditional branching much more often, and it is encoded as follows:</p><ul><li>The T1 encoding allows an additional condition in the instruction but has a smaller immediate value (8 bits).</li><li>the T2 encoding has a larger immediate value (11 bits). This is important because we often want to branch far away.</li></ul><p>For both encodings, the assembler divides the immediate value by 2 in the instruction, and this gets shifted left by 1 bit when executed.</p><img src=/courses/cs3420/lecture03/branch_encoding.png alt="Branch encodings" width=80% class=center><figcaption>Fig. 4. Conditional branch encodings.</figcaption><p>Sometimes, we want to move really really far away. This is when a 32-bit instruction would be useful. The branch & link does exactly this.</p><img src=/courses/cs3420/lecture03/bnl.png alt="Branch & link encodings" width=80% class=center><figcaption>Fig. 4. Branch & link encodings.</figcaption><p>This 32-bit instruction is actually two instructions, but bits 15 to 11 of the first instruction are <code>11110</code>, which is <code>0x1E</code>. Recall that this tells the processor that this instruction is 32 bits.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>