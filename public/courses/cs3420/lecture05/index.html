<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 5: C | Jiming Chen</title><meta name=keywords content><meta name=description content="The C program build tool flow includes

source files (.c, .h) which are compiled into object files (.o)
assmebly files (.s) which are assembled into object files (.o)
library files (.lib)

All of these are linked into memory into an executable file (.exe, .axf).
Assembly Files
In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture05/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture05/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture05/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 5: C"><meta property="og:description" content="The C program build tool flow includes
source files (.c, .h) which are compiled into object files (.o) assmebly files (.s) which are assembled into object files (.o) library files (.lib) All of these are linked into memory into an executable file (.exe, .axf).
Assembly Files In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-04T13:29:39-05:00"><meta property="article:modified_time" content="2025-02-04T13:29:39-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 5: C"><meta name=twitter:description content="The C program build tool flow includes

source files (.c, .h) which are compiled into object files (.o)
assmebly files (.s) which are assembled into object files (.o)
library files (.lib)

All of these are linked into memory into an executable file (.exe, .axf).
Assembly Files
In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 5: C","item":"https://jiming-chen.github.io/courses/cs3420/lecture05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 5: C","name":"Lecture 5: C","description":"The C program build tool flow includes\nsource files (.c, .h) which are compiled into object files (.o) assmebly files (.s) which are assembled into object files (.o) library files (.lib) All of these are linked into memory into an executable file (.exe, .axf).\nAssembly Files In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file.\n","keywords":[],"articleBody":"The C program build tool flow includes\nsource files (.c, .h) which are compiled into object files (.o) assmebly files (.s) which are assembled into object files (.o) library files (.lib) All of these are linked into memory into an executable file (.exe, .axf).\nAssembly Files In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file.\nImportantly, the label main will be available to other object files during linking. When you have an instruction using a non-main label like LDR R0, -hex_number, the assembler precomputes the offset so that other object files cannot use that label.\nFiles with a .h extension are header files and are included in .c files. The convention is for them to have the same name, and they get compiled into one object file. Before, the C files are compiled, the header files are literally copied and pasted into the top of the C files that include those header files.\nIf you have a linking error, it could mean there are two functions with the same name or there is no implementation of an expected function.\nThe header function can be thought of as containing function prototypes, which include the function name, arguments names and types, and return type.\nWhen a C file (or compilation unit) is compiled, the object file should have labels for each function and variable. However, by default, labels for non-main functions in C files can not be referred to by other C files. Therefore, you must advertise that something is accessible to other files. This is done like so: extern int myvar;. It is usually put in the header file. Accordingly, you cannot make another variable with the same name as an externed variable or else the linker will get upset.\nRecall our memory map. Since SRAM is cheaper to manipulate, variables get addresses allocated in the SRAM section (or mostly in the SRAM section). The code then gets memory allocated in the flash memory.\nFig. 1. Memory allocation in C. Implementing Control Flows How would you implement an if-then-else block in assembly? This is done by having if, thn1, els1, thn2, els2, and end blocks. This is what an unoptimized C compiler does.\nAnother control flow is the the switch control flow which compares a value to multiple values and a default value. This is done by using labels for each case as well as an end label. This makes it apparent why case blocks need break; statements. Using the switch control flow is easier to read because each case depends on the same variable or expression, and it can be implemented more efficiently in assembly.\nA for loop can implemented with for, next, and end labels. Inside the next block, we use a condition which is the opposite of the loop condition that points to the end block. Note that adding the counting register and comparing takes more clock cycles than inititializing the counter to #NUM and subtracting one because subtraction automatically sets the condition flags.\nFunction Calls A C program consists of at least one function, which can also be called a subroutine. A function can take arguments and can return a result. Functions are useful because we can reuse code and make programs more modular. A subroutine should be callable from different program locations and should support nested/recursive calls.\nHow does a function receive parameters? Do we give it a register or a memory location?\nWe can have a corresponding assembly block for the caller (s = func(1,2,3)) in which we move immediately values into registers and then branch to the func label. Then, inside the assembly code that corresponds to the func implementation, we can do calcaulations with the registers that were just set.\nWe can simply set the return address to R0, but hard-coding the return address doesn’t work when you want to call another function inside the original function. To solve this problem, we can use the ADR instruction which can compute and store the return address in the link register when we return then branch back to the function which called the function.\nHowever, there is an instruction called BL that does all of this in one swoop which makes calling functions very easy like so: BL func. We still need to use BX LR to return, but the link register holds the address of the most recently called function, which can cause an infinite loop with multiple functions.\nTo fix this problem, we use stacks.\nStacks A stack is a last-in first-out data structure, and the stack pointer points to the last item on the stack. The stack grows toward smaller addresses. Stacks has pop and push operations.\nThe stack pointer points to words, so its last two bits should be 0. We can implement PUSH {R4} by first decrementing the stack pointer then storing the register: SUB SP, SP, #4, STR R4, [SP, #0].\nIn ARM, we can PUSH and POP multiple registers to a register. Also, we can use POP {PC}, which pops a stack and branches to that address.\nARM vs. Thumb Mode ARM code works in 32-bit instruction mode while thumb code is largely in 16- bit instruction mode. It is possible to wrap code from different modes within each other, and we call this interworking.\nAs a result, if we branch into a different mode, we want the processor to be able to change modes. If we manipulate the PC register and the last bit is 1, then the processor knows to execute in thumb mode. We don’t lose information by doing this because all addresses are even anyway.\n","wordCount":"961","inLanguage":"en","datePublished":"2025-02-04T13:29:39-05:00","dateModified":"2025-02-04T13:29:39-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture05/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 5: C</h1><div class=post-meta><span title='2025-02-04 13:29:39 -0500 -0500'>February 4, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#assembly-files>Assembly Files</a></li><li><a href=#implementing-control-flows>Implementing Control Flows</a></li><li><a href=#function-calls>Function Calls</a><ul><li><a href=#stacks>Stacks</a></li></ul></li><li><a href=#arm-vs-thumb-mode>ARM vs. Thumb Mode</a></li></ul></nav></div></details></div><div class=post-content><p>The C program build tool flow includes</p><ul><li>source files (.c, .h) which are compiled into object files (.o)</li><li>assmebly files (.s) which are assembled into object files (.o)</li><li>library files (.lib)</li></ul><p>All of these are linked into memory into an executable file (.exe, .axf).</p><h2 id=assembly-files>Assembly Files<a hidden class=anchor aria-hidden=true href=#assembly-files>#</a></h2><p>In assembly files, sections of (binary) instructions can be referred to using memory addresses which, in the assembly file, are called labels. In the assembled object file, the main memory locations point to each label in the assembly file.</p><p>Importantly, the label <code>main</code> will be available to other object files during linking. When you have an instruction using a non-main label like <code>LDR R0, -hex_number</code>, the assembler precomputes the offset so that other object files cannot use that label.</p><p>Files with a <code>.h</code> extension are header files and are included in <code>.c</code> files. The convention is for them to have the same name, and they get compiled into one object file. Before, the C files are compiled, the header files are literally copied and pasted into the top of the C files that include those header files.</p><p>If you have a linking error, it could mean there are two functions with the same name or there is no implementation of an expected function.</p><p>The header function can be thought of as containing function prototypes, which include the function name, arguments names and types, and return type.</p><p>When a C file (or compilation unit) is compiled, the object file should have labels for each function and variable. However, by default, labels for non-main functions in C files can not be referred to by other C files. Therefore, you must advertise that something is accessible to other files. This is done like so: <code>extern int myvar;</code>. It is usually put in the header file. Accordingly, you cannot make another variable with the same name as an externed variable or else the linker will get upset.</p><p>Recall our memory map. Since SRAM is cheaper to manipulate, variables get addresses allocated in the SRAM section (or mostly in the SRAM section). The code then gets memory allocated in the flash memory.</p><img src=/courses/cs3420/lecture05/memory.png alt="Memory allocation in C" width=80% class=center><figcaption>Fig. 1. Memory allocation in C.</figcaption><h2 id=implementing-control-flows>Implementing Control Flows<a hidden class=anchor aria-hidden=true href=#implementing-control-flows>#</a></h2><p>How would you implement an if-then-else block in assembly? This is done by having <code>if</code>, <code>thn1</code>, <code>els1</code>, <code>thn2</code>, <code>els2</code>, and <code>end</code> blocks. This is what an unoptimized C compiler does.</p><p>Another control flow is the the switch control flow which compares a value to multiple values and a default value. This is done by using labels for each case as well as an <code>end</code> label. This makes it apparent why case blocks need <code>break;</code> statements. Using the switch control flow is easier to read because each case depends on the same variable or expression, and it can be implemented more efficiently in assembly.</p><p>A for loop can implemented with <code>for</code>, <code>next</code>, and <code>end</code> labels. Inside the <code>next</code> block, we use a condition which is the opposite of the loop condition that points to the <code>end</code> block. Note that adding the counting register and comparing takes more clock cycles than inititializing the counter to <code>#NUM</code> and subtracting one because subtraction automatically sets the condition flags.</p><h2 id=function-calls>Function Calls<a hidden class=anchor aria-hidden=true href=#function-calls>#</a></h2><p>A C program consists of at least one function, which can also be called a subroutine. A function can take arguments and can return a result. Functions are useful because we can reuse code and make programs more modular. A subroutine should be callable from different program locations and should support nested/recursive calls.</p><p>How does a function receive parameters? Do we give it a register or a memory location?</p><p>We can have a corresponding assembly block for the caller (<code>s = func(1,2,3)</code>) in which we move immediately values into registers and then branch to the <code>func</code> label. Then, inside the assembly code that corresponds to the <code>func</code> implementation, we can do calcaulations with the registers that were just set.</p><p>We can simply set the return address to <code>R0</code>, but hard-coding the return address doesn&rsquo;t work when you want to call another function inside the original function. To solve this problem, we can use the <code>ADR</code> instruction which can compute and store the return address in the link register when we return then branch back to the function which called the function.</p><p>However, there is an instruction called <code>BL</code> that does all of this in one swoop which makes calling functions very easy like so: <code>BL func</code>. We still need to use <code>BX LR</code> to return, but the link register holds the address of the most recently called function, which can cause an infinite loop with multiple functions.</p><p>To fix this problem, we use stacks.</p><h3 id=stacks>Stacks<a hidden class=anchor aria-hidden=true href=#stacks>#</a></h3><p>A stack is a last-in first-out data structure, and the stack pointer points to the last item on the stack. The stack grows toward smaller addresses. Stacks has pop and push operations.</p><p>The stack pointer points to words, so its last two bits should be 0. We can implement <code>PUSH {R4}</code> by first decrementing the stack pointer then storing the register: <code>SUB SP, SP, #4</code>, <code>STR R4, [SP, #0]</code>.</p><p>In ARM, we can <code>PUSH</code> and <code>POP</code> multiple registers to a register. Also, we can use <code>POP {PC}</code>, which pops a stack and branches to that address.</p><h2 id=arm-vs-thumb-mode>ARM vs. Thumb Mode<a hidden class=anchor aria-hidden=true href=#arm-vs-thumb-mode>#</a></h2><p>ARM code works in 32-bit instruction mode while thumb code is largely in 16- bit instruction mode. It is possible to wrap code from different modes within each other, and we call this <em>interworking</em>.</p><p>As a result, if we branch into a different mode, we want the processor to be able to change modes. If we manipulate the PC register and the last bit is 1, then the processor knows to execute in thumb mode. We don&rsquo;t lose information by doing this because all addresses are even anyway.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>