<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 9: Communication Protocols | Jiming Chen</title><meta name=keywords content><meta name=description content="ISR Recap
Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).
There are two types of interrupts:

Non-maskable interrupts cannot be disabled, such as resets or HardFaults.
Maskable interrupts are the most common. These are controlled by the user and can be selectively activated.

Additionally, recall that in our case, we need to enable interrupts, which requires several things:"><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture09/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture09/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture09/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 9: Communication Protocols"><meta property="og:description" content="ISR Recap Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).
There are two types of interrupts:
Non-maskable interrupts cannot be disabled, such as resets or HardFaults. Maskable interrupts are the most common. These are controlled by the user and can be selectively activated. Additionally, recall that in our case, we need to enable interrupts, which requires several things:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-20T13:37:25-05:00"><meta property="article:modified_time" content="2025-02-20T13:37:25-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 9: Communication Protocols"><meta name=twitter:description content="ISR Recap
Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).
There are two types of interrupts:

Non-maskable interrupts cannot be disabled, such as resets or HardFaults.
Maskable interrupts are the most common. These are controlled by the user and can be selectively activated.

Additionally, recall that in our case, we need to enable interrupts, which requires several things:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 9: Communication Protocols","item":"https://jiming-chen.github.io/courses/cs3420/lecture09/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 9: Communication Protocols","name":"Lecture 9: Communication Protocols","description":"ISR Recap Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).\nThere are two types of interrupts:\nNon-maskable interrupts cannot be disabled, such as resets or HardFaults. Maskable interrupts are the most common. These are controlled by the user and can be selectively activated. Additionally, recall that in our case, we need to enable interrupts, which requires several things:\n","keywords":[],"articleBody":"ISR Recap Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).\nThere are two types of interrupts:\nNon-maskable interrupts cannot be disabled, such as resets or HardFaults. Maskable interrupts are the most common. These are controlled by the user and can be selectively activated. Additionally, recall that in our case, we need to enable interrupts, which requires several things:\nWe need to enable interrupts on the peripheral, which is done by setting a configuration bit in the address space of the peripheral. We need to configure the NVIC to accept interrupts, which is done through the NVIC_ISER (interrupt set enable register). Finally, there is a global interrupt enable we need to set. If you have multiple IO devices, there is an exception number and vector table for figuring out which device raised the interrupt. Then, we also priority, where a lower IRQ in the table goes first.\nWhile mot exceptions are prioritized as they happen, some priorities are fixed. For example, reset has priority -3, which is the highest priority. Additionally, we may adjust the priorities of other peripheral exceptions.\nIf a new exception is requested while an exception is currently being executed, if the newer one has higher priotity, then that one gets executed while if it has lower priority, it gets executed after.\nRecall that variables modified in the ISR should be declared as volatile.\nCommunication Protocols A bus is a shared wire that a lot of nodes share between them. But there are still questions we might have. Do we do serial or parallel, clock or no clock? How do we know who the data is to or from? What if there are multiple things to be sent at once? How to handle errors?\nCAN Bus The Controller Area Network* is a vehicle bu standard developed in 1983. It can be thought of industrial strenth noise resistant transmission. It is used in transmission, ABS, controls, etc. in cars, for example. It is common in “harsh” environments.\nCAN is serial, meaning one bit is transmitted at a time. There is no clock line because the data line is “self-clocked.” There is a multi-controller so that anyone can initiate transmission. There is no “deveice address,” but rather a “message ID.” CAN uses differential signaling, meaning the ground depends on the two endpoints rather than an actual ground, meaning it uses two twisted wires.\nIf a line has high priority, then the signal is active-low. Otherwise, it is active-high. Then, a wired AND is used for bit-wise arbitration. Therefore, if anyone is transmitting 0, then the bus will show 0.\nAll message start with 0 after an “Inter-Frame-Space” (long period) of 1. Then, an 11-bit base message message ID. At the end, you can check whether the data was corrupted with a checksum.\nHow do noes know when to read the bus without an explicit clock signal? We need them to be synchronized by themselves. The way we do this is by introducing transitions every five bits into the message where everyone can synchronize. This is done by hardware, so when we write software don’t have to worry about this.\nI$^2$C The inter-integrated circuit is used in cheap embedded environments like robotics. Data (SDA) is serial, and there is a clock line (SCL). SCL is driven by the controller while SDA is driven by either the controller or the nodes. There is the same wired AND.\n","wordCount":"590","inLanguage":"en","datePublished":"2025-02-20T13:37:25-05:00","dateModified":"2025-02-20T13:37:25-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture09/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 9: Communication Protocols</h1><div class=post-meta><span title='2025-02-20 13:37:25 -0500 -0500'>February 20, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#isr-recap>ISR Recap</a></li><li><a href=#communication-protocols>Communication Protocols</a><ul><li><a href=#can-bus>CAN Bus</a></li></ul></li><li><a href=#i2c>I$^2$C</a></li></ul></nav></div></details></div><div class=post-content><h2 id=isr-recap>ISR Recap<a hidden class=anchor aria-hidden=true href=#isr-recap>#</a></h2><p>Recall that ISRs are like functions, and the processor is hardwired to execute ISR and return. This includes pushing the context onto the stack (everything needed to resume execution as if nothing happened).</p><p>There are two types of interrupts:</p><ul><li>Non-maskable interrupts cannot be disabled, such as resets or HardFaults.</li><li>Maskable interrupts are the most common. These are controlled by the user and can be selectively activated.</li></ul><p>Additionally, recall that in our case, we need to enable interrupts, which requires several things:</p><ol><li>We need to enable interrupts on the peripheral, which is done by setting a configuration bit in the address space of the peripheral.</li><li>We need to configure the NVIC to accept interrupts, which is done through the NVIC_ISER (interrupt set enable register).</li><li>Finally, there is a global interrupt enable we need to set.</li></ol><p>If you have multiple IO devices, there is an exception number and vector table for figuring out which device raised the interrupt. Then, we also priority, where a lower IRQ in the table goes first.</p><p>While mot exceptions are prioritized as they happen, some priorities are fixed. For example, reset has priority -3, which is the highest priority. Additionally, we may adjust the priorities of other peripheral exceptions.</p><p>If a new exception is requested while an exception is currently being executed, if the newer one has higher priotity, then that one gets executed while if it has lower priority, it gets executed after.</p><p>Recall that variables modified in the ISR should be declared as <code>volatile</code>.</p><h2 id=communication-protocols>Communication Protocols<a hidden class=anchor aria-hidden=true href=#communication-protocols>#</a></h2><p>A <em>bus</em> is a shared wire that a lot of nodes share between them. But there are still questions we might have. Do we do serial or parallel, clock or no clock? How do we know who the data is to or from? What if there are multiple things to be sent at once? How to handle errors?</p><h3 id=can-bus>CAN Bus<a hidden class=anchor aria-hidden=true href=#can-bus>#</a></h3><p>The <em>Controller Area Network</em>* is a vehicle bu standard developed in 1983. It can be thought of industrial strenth noise resistant transmission. It is used in transmission, ABS, controls, etc. in cars, for example. It is common in &ldquo;harsh&rdquo; environments.</p><p>CAN is serial, meaning one bit is transmitted at a time. There is no clock line because the data line is &ldquo;self-clocked.&rdquo; There is a multi-controller so that anyone can initiate transmission. There is no &ldquo;deveice address,&rdquo; but rather a &ldquo;message ID.&rdquo; CAN uses differential signaling, meaning the ground depends on the two endpoints rather than an actual ground, meaning it uses two twisted wires.</p><p>If a line has high priority, then the signal is active-low. Otherwise, it is active-high. Then, a wired AND is used for bit-wise arbitration. Therefore, if anyone is transmitting 0, then the bus will show 0.</p><p>All message start with 0 after an &ldquo;Inter-Frame-Space&rdquo; (long period) of 1. Then, an 11-bit base message message ID. At the end, you can check whether the data was corrupted with a checksum.</p><p>How do noes know when to read the bus without an explicit clock signal? We need them to be synchronized by themselves. The way we do this is by introducing transitions every five bits into the message where everyone can synchronize. This is done by hardware, so when we write software don&rsquo;t have to worry about this.</p><h2 id=i2c>I$^2$C<a hidden class=anchor aria-hidden=true href=#i2c>#</a></h2><p>The <em>inter-integrated circuit</em> is used in cheap embedded environments like robotics. Data (SDA) is serial, and there is a clock line (SCL). SCL is driven by the controller while SDA is driven by either the controller or the nodes. There is the same wired AND.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>