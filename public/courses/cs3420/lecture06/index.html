<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 6: Function Calls and Program Memory Layout | Jiming Chen</title><meta name=keywords content><meta name=description content="Function Calls
If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.
We can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can&rsquo;t do POP LR because LR is not a lower register.
PUSH Encoding
With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture06/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture06/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture06/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 6: Function Calls and Program Memory Layout"><meta property="og:description" content="Function Calls If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.
We can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can’t do POP LR because LR is not a lower register.
PUSH Encoding With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-06T13:27:42-05:00"><meta property="article:modified_time" content="2025-02-06T13:27:42-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 6: Function Calls and Program Memory Layout"><meta name=twitter:description content="Function Calls
If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.
We can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can&rsquo;t do POP LR because LR is not a lower register.
PUSH Encoding
With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 6: Function Calls and Program Memory Layout","item":"https://jiming-chen.github.io/courses/cs3420/lecture06/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 6: Function Calls and Program Memory Layout","name":"Lecture 6: Function Calls and Program Memory Layout","description":"Function Calls If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.\nWe can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can\u0026rsquo;t do POP LR because LR is not a lower register.\nPUSH Encoding With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions.\n","keywords":[],"articleBody":"Function Calls If we want to implement POP {R4}, we first store the value in the stack pointer to R4 then increment the stack pointer by 4 because the stack grows down.\nWe can also do POP {PC}, which is equivalent to POP {Rx} followed by BX Rx. We can’t do POP LR because LR is not a lower register.\nPUSH Encoding With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions.\nFig. 1. T1 Encoding for PUSH Instruction. In one-hot encoding, bit n being 1 means Rn should be pushed.\nSaving LR in Stack Once we have stacks, we can save the value of LR in a stack for each function call. Then, when it’s time to return, we pop the correct value of LR into a register then branch to that value.\nHowever, functions need to manipulate registers, so they may override the registers that are used for function calling.\nSaving and Restoring Registers We can do two things\nThe caller can save its registers by using PUSH and POP to save the contents of the registers into memory and retrieve after the BL func. The order of the registers has to be switched though (we don’t have to worry about this if using one instruction because of one-hot encoding), and also, pushing and popping each take 2 cycles per register. The callee normally begins with PUSH LR and ends with POP PC but instead, we can put PUSH R4 after the initial push and do POP {R4} before the final pop. Inline Another thing we can do is use the inline keyword in a C function header which tells the compiler to copy and paste the function code into wherever it is called. This results in a larger executable, but if a function is called a lot, this can be beneficial, as there is no branching\nARM Calling Convention The ARM convention is that the caller has the responsibility to save registers R0 through R3. If there are more than four arguments, the rest get pushed to the stack (in reverse order). It is the callee’s (function body’s) responsibility to save R4 through R8 and higher registers if needed because the caller expects them to be preserved. You don’t need to save them if you don’t use them as long as they are preserved for the caller. It is important to follow this convention because later we will write assembly code to be called by a compiled C function, and the C compiler follows this convention.\nFig. 2. AAPCS Core Register Use. Sometimes functions call other functions, in which case, a block of code can act as a callee and a caller. Then, the callee would need to still store LR.\nIn C, the calling convention says that the return value goes in R0. For larger return types, R0 could hold the address to the return value.\nMemory Layout Local Variables For local variables, local variables are allocated in the stack, and a fixed address and amount of memory is allocated by the C compiler (although they may be stored in registers for optimization).\nWhen reading local variables, we can use a LDR, but if we do that, the offset we do later has to be a multiple of 4.\nActivation Record One way to think of the stack is a record of everything happening in the program. The stuff related to the main function go to the bottom of the stack (highest address). Then, foo1’s stuff go lower in the address space in the following order: parameters, return address, callee-saved registers, then local variables. Since we have a lot of memory, we can afford a lot of function calls.\nProgram Memory Use The Flash ROM is layed out in the following order:\nConstant Data, e.g. const char c=123; Initialization Data, e.g. int d=31; Startup and Runtime Library Code Program .text The RAM has the following layout:\nZero-Initialized Data Initialized Data, e.g. int d=31; Stack Heap Data The heap is written to from the bottom up while the stack is written to from the top down. Then, they can intrude into each other’s boundaries until they collide so that memory use can be maximized.\nWhen a program is run, initialization data and constant data are stored in the flash ROM, and once the compiler allocates memory for variables, the data is copied from ROM to RAM. Note that there is still difference between initialized data and variables (in stack) within the RAM.\n","wordCount":"752","inLanguage":"en","datePublished":"2025-02-06T13:27:42-05:00","dateModified":"2025-02-06T13:27:42-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture06/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 6: Function Calls and Program Memory Layout</h1><div class=post-meta><span title='2025-02-06 13:27:42 -0500 -0500'>February 6, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#function-calls>Function Calls</a><ul><li><a href=#push-encoding>PUSH Encoding</a></li><li><a href=#saving-lr-in-stack>Saving LR in Stack</a></li><li><a href=#saving-and-restoring-registers>Saving and Restoring Registers</a></li><li><a href=#inline>Inline</a></li><li><a href=#arm-calling-convention>ARM Calling Convention</a></li></ul></li><li><a href=#memory-layout>Memory Layout</a><ul><li><a href=#local-variables>Local Variables</a></li><li><a href=#activation-record>Activation Record</a></li><li><a href=#program-memory-use>Program Memory Use</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=function-calls>Function Calls<a hidden class=anchor aria-hidden=true href=#function-calls>#</a></h2><p>If we want to implement <code>POP {R4}</code>, we first store the value in the stack pointer to <code>R4</code> then increment the stack pointer by 4 because the stack grows down.</p><p>We can also do <code>POP {PC}</code>, which is equivalent to <code>POP {Rx}</code> followed by <code>BX Rx</code>. We can&rsquo;t do <code>POP LR</code> because <code>LR</code> is not a lower register.</p><h3 id=push-encoding>PUSH Encoding<a hidden class=anchor aria-hidden=true href=#push-encoding>#</a></h3><p>With the PUSH encoding, we encode a list of registers using a one-hot encoding to save instructions.</p><img src=/courses/cs3420/lecture06/push.png alt="PUSH T1 Encoding" width=80% class=center><figcaption>Fig. 1. T1 Encoding for PUSH Instruction.</figcaption><p>In one-hot encoding, bit <code>n</code> being 1 means <code>Rn</code> should be pushed.</p><h3 id=saving-lr-in-stack>Saving LR in Stack<a hidden class=anchor aria-hidden=true href=#saving-lr-in-stack>#</a></h3><p>Once we have stacks, we can save the value of <code>LR</code> in a stack for each function call. Then, when it&rsquo;s time to return, we pop the correct value of <code>LR</code> into a register then branch to that value.</p><p>However, functions need to manipulate registers, so they may override the registers that are used for function calling.</p><h3 id=saving-and-restoring-registers>Saving and Restoring Registers<a hidden class=anchor aria-hidden=true href=#saving-and-restoring-registers>#</a></h3><p>We can do two things</p><ol><li>The caller can save its registers by using <code>PUSH</code> and <code>POP</code> to save the contents of the registers into memory and retrieve after the <code>BL func</code>. The order of the registers has to be switched though (we don&rsquo;t have to worry about this if using one instruction because of one-hot encoding), and also, pushing and popping each take 2 cycles per register.</li><li>The callee normally begins with <code>PUSH LR</code> and ends with <code>POP PC</code> but instead, we can put <code>PUSH R4</code> after the initial push and do <code>POP {R4}</code> before the final pop.</li></ol><h3 id=inline>Inline<a hidden class=anchor aria-hidden=true href=#inline>#</a></h3><p>Another thing we can do is use the <code>inline</code> keyword in a C function header which tells the compiler to copy and paste the function code into wherever it is called. This results in a larger executable, but if a function is called a lot, this can be beneficial, as there is no branching</p><h3 id=arm-calling-convention>ARM Calling Convention<a hidden class=anchor aria-hidden=true href=#arm-calling-convention>#</a></h3><p>The ARM convention is that the caller has the responsibility to save registers R0 through R3. If there are more than four arguments, the rest get pushed to the stack (in reverse order). It is the callee&rsquo;s (function body&rsquo;s) responsibility to save R4 through R8 and higher registers if needed because the caller expects them to be preserved. You don&rsquo;t need to save them if you don&rsquo;t use them as long as they are preserved for the caller. It is important to follow this convention because later we will write assembly code to be called by a compiled C function, and the C compiler follows this convention.</p><img src=/courses/cs3420/lecture06/registers.png alt="ARM Calling Convention Register Table" width=80% class=center><figcaption>Fig. 2. AAPCS Core Register Use.</figcaption><p>Sometimes functions call other functions, in which case, a block of code can act as a callee and a caller. Then, the callee would need to still store <code>LR</code>.</p><p>In C, the calling convention says that the return value goes in R0. For larger return types, R0 could hold the address to the return value.</p><h2 id=memory-layout>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout>#</a></h2><h3 id=local-variables>Local Variables<a hidden class=anchor aria-hidden=true href=#local-variables>#</a></h3><p>For local variables, local variables are allocated in the stack, and a fixed address and amount of memory is allocated by the C compiler (although they may be stored in registers for optimization).</p><p>When reading local variables, we can use a <code>LDR</code>, but if we do that, the offset we do later has to be a multiple of 4.</p><h3 id=activation-record>Activation Record<a hidden class=anchor aria-hidden=true href=#activation-record>#</a></h3><p>One way to think of the stack is a record of everything happening in the program. The stuff related to the <code>main</code> function go to the bottom of the stack (highest address). Then, <code>foo1</code>&rsquo;s stuff go lower in the address space in the following order: parameters, return address, callee-saved registers, then local variables. Since we have a lot of memory, we can afford a lot of function calls.</p><h3 id=program-memory-use>Program Memory Use<a hidden class=anchor aria-hidden=true href=#program-memory-use>#</a></h3><p>The Flash ROM is layed out in the following order:</p><ul><li>Constant Data, e.g. <code>const char c=123;</code></li><li>Initialization Data, e.g. <code>int d=31;</code></li><li>Startup and Runtime Library Code</li><li>Program .text</li></ul><p>The RAM has the following layout:</p><ul><li>Zero-Initialized Data</li><li>Initialized Data, e.g. <code>int d=31;</code></li><li>Stack</li><li>Heap Data</li></ul><p>The heap is written to from the bottom up while the stack is written to from the top down. Then, they can intrude into each other&rsquo;s boundaries until they collide so that memory use can be maximized.</p><p>When a program is run, initialization data and constant data are stored in the flash ROM, and once the compiler allocates memory for variables, the data is copied from ROM to RAM. Note that there is still difference between initialized data and variables (in stack) within the RAM.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>