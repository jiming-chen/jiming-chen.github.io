<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 8: Interrupts and Exceptions | Jiming Chen</title><meta name=keywords content><meta name=description content="Let&rsquo;s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.
One way to know if a button pressed is polling, where a loop continually reads the GPIO port.
Another option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture08/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture08/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture08/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 8: Interrupts and Exceptions"><meta property="og:description" content="Let’s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.
One way to know if a button pressed is polling, where a loop continually reads the GPIO port.
Another option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-13T13:33:09-05:00"><meta property="article:modified_time" content="2025-02-13T13:33:09-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 8: Interrupts and Exceptions"><meta name=twitter:description content="Let&rsquo;s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.
One way to know if a button pressed is polling, where a loop continually reads the GPIO port.
Another option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 8: Interrupts and Exceptions","item":"https://jiming-chen.github.io/courses/cs3420/lecture08/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 8: Interrupts and Exceptions","name":"Lecture 8: Interrupts and Exceptions","description":"Let\u0026rsquo;s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.\nOne way to know if a button pressed is polling, where a loop continually reads the GPIO port.\nAnother option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code.\n","keywords":[],"articleBody":"Let’s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.\nOne way to know if a button pressed is polling, where a loop continually reads the GPIO port.\nAnother option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an interrupt service routine (ISR) and go back to the main code.\nPolling and interrupts have their own benefits:\nPolling is simple and easy to implement. Polling can be slow and wasteful of CPU time. Polling scales poorly. Polling can be bad for precise timing. For example, polling if button 9 was pressed then button 2, the for loop could detect 2 first. Interrupts are efficient because code runs only when necessary. Interrupts are fast because they are in hardware. Interrupts scale well. Interrupts are more complicated to implement and can be very difficult to debug. Interrupts require processor support. Interrupt Handling Interrupts may look like function calls, so what are the differences? Compared to function calls, the main code does not know that the ISR will be run, so it can’t prepare for the PC change by doing things like preparing input arguments. As a result, inside the ISR, the processor should be in a high privilege mode so it can change whatever.\nWhen you enter an interrupt handler, the hardware saves the PC (and registers) and enters a privileged mode. Then, it jumps to the PC specified in the interrupt vector table.\nInside the ISR, the ISR saves registers that will be used then might disrupt additional interrupts. The ISR finds out why the interrupt is happening and executes the code. Then, it returns.\nWhen the interrupt is done, the hardware restores the registers saved from before the ISR, switches the privilege mode back, and jumps back to the original PC.\nUsually, the interrupt will alow the current instruction to finish running before interrupting.\nAs opposed to interrupts, exceptions are synchronous. Exceptions happen for arithmetic overflow, floating point anomaly, page fault, etc.\nException Handling The CPU is hardwired to handle exceptions.\nFirst, it finishes the current instruction (unless it is lengthy, like multiplication). Then, it pushes context onto the current stack (xPSR, return address, LR, R12, R3, R2, R1, R0). Recall that xPSR contains the status flags, which we need (for example, if the interrupt happened between a CMP and BEQ). It switches to privileged mode. It loads PC with address of exception handler. It loads LR with a special EXC_RETURN code. It loads IPSR with exception number. Finally, it starts executing the exception code. All of this takes about 16 cycles.\nThe vector table contains a lot of addresses which the PC can go to to execute the code. One example is the HardFault, which the PC goes to if you do an unaligned memory access.\nEXC_RETURN tells the CPU what return mode to return in and what stack to return. There are three different combinations: Handler/MSP, Thread/MSP, and Thread/PSP.\nWhen writing an ISR, there are a few things to keep in mind:\nTry to keep it short. Since it can go anywhere in code, if it is too long, it can change behavior. You might need to explicitly clear the source of the interrupt or else once the interrupt finishes, it can immediately trigger again. It should not have side effects since it can be run at any time. It ISRs are written correctly, they can be very effective because you can write code for different scenarios in isolation.\nVolatile The volatile keyword can be used to force a compiler to fetch a variable from memory each time it is accessed. Imagine you have a program with an ISR that updates a variable. The compiler may have that variable in a register and save it when it was updated in memory.\nARM On ARM specifically, you must enable interrupts on the peripheral. There is a configurable bit in the address space of the peripheral called the interrupt enable.\nYou also must configure the NVIC to accept interrupts. Finally, there is a global interrupt enable.\n","wordCount":"716","inLanguage":"en","datePublished":"2025-02-13T13:33:09-05:00","dateModified":"2025-02-13T13:33:09-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture08/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 8: Interrupts and Exceptions</h1><div class=post-meta><span title='2025-02-13 13:33:09 -0500 EST'>February 13, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#interrupt-handling>Interrupt Handling</a></li><li><a href=#exception-handling>Exception Handling</a></li><li><a href=#volatile>Volatile</a></li><li><a href=#arm>ARM</a></li></ul></nav></div></details></div><div class=post-content><p>Let&rsquo;s say your embedded device has some buttons, which are ways the user can interract with the program. We want the user to be able to respond appropriately in all situations. For example, if a user presses two buttons at once, the program should not crash.</p><p>One way to know if a button pressed is <em>polling</em>, where a loop continually reads the GPIO port.</p><p>Another option is to have an interrupt, in which the main code causes the program counter to move to another chunk of code called an <em>interrupt service routine</em> (ISR) and go back to the main code.</p><p>Polling and interrupts have their own benefits:</p><ul><li>Polling is simple and easy to implement.</li><li>Polling can be slow and wasteful of CPU time.</li><li>Polling scales poorly.</li><li>Polling can be bad for precise timing. For example, polling if button 9 was pressed then button 2, the for loop could detect 2 first.</li><li>Interrupts are efficient because code runs only when necessary.</li><li>Interrupts are fast because they are in hardware.</li><li>Interrupts scale well.</li><li>Interrupts are more complicated to implement and can be very difficult to debug.</li><li>Interrupts require processor support.</li></ul><h2 id=interrupt-handling>Interrupt Handling<a hidden class=anchor aria-hidden=true href=#interrupt-handling>#</a></h2><p>Interrupts may look like function calls, so what are the differences? Compared to function calls, the main code does not know that the ISR will be run, so it can&rsquo;t prepare for the PC change by doing things like preparing input arguments. As a result, inside the ISR, the processor should be in a high privilege mode so it can change whatever.</p><p>When you enter an interrupt handler, the hardware saves the PC (and registers) and enters a privileged mode. Then, it jumps to the PC specified in the interrupt vector table.</p><p>Inside the ISR, the ISR saves registers that will be used then might disrupt additional interrupts. The ISR finds out why the interrupt is happening and executes the code. Then, it returns.</p><p>When the interrupt is done, the hardware restores the registers saved from before the ISR, switches the privilege mode back, and jumps back to the original PC.</p><p>Usually, the interrupt will alow the current instruction to finish running before interrupting.</p><p>As opposed to interrupts, exceptions are synchronous. Exceptions happen for arithmetic overflow, floating point anomaly, page fault, etc.</p><h2 id=exception-handling>Exception Handling<a hidden class=anchor aria-hidden=true href=#exception-handling>#</a></h2><p>The CPU is hardwired to handle exceptions.</p><ol><li>First, it finishes the current instruction (unless it is lengthy, like multiplication).</li><li>Then, it pushes context onto the current stack (xPSR, return address, LR, R12, R3, R2, R1, R0). Recall that xPSR contains the status flags, which we need (for example, if the interrupt happened between a <code>CMP</code> and <code>BEQ</code>).</li><li>It switches to privileged mode.</li><li>It loads PC with address of exception handler.</li><li>It loads LR with a special EXC_RETURN code.</li><li>It loads IPSR with exception number.</li><li>Finally, it starts executing the exception code.</li></ol><p>All of this takes about 16 cycles.</p><p>The vector table contains a lot of addresses which the PC can go to to execute the code. One example is the HardFault, which the PC goes to if you do an unaligned memory access.</p><p><code>EXC_RETURN</code> tells the CPU what return mode to return in and what stack to return. There are three different combinations: Handler/MSP, Thread/MSP, and Thread/PSP.</p><p>When writing an ISR, there are a few things to keep in mind:</p><ul><li>Try to keep it short. Since it can go anywhere in code, if it is too long, it can change behavior.</li><li>You might need to explicitly clear the source of the interrupt or else once the interrupt finishes, it can immediately trigger again.</li><li>It should not have side effects since it can be run at any time.</li></ul><p>It ISRs are written correctly, they can be very effective because you can write code for different scenarios in isolation.</p><h2 id=volatile>Volatile<a hidden class=anchor aria-hidden=true href=#volatile>#</a></h2><p>The <code>volatile</code> keyword can be used to force a compiler to fetch a variable from memory each time it is accessed. Imagine you have a program with an ISR that updates a variable. The compiler may have that variable in a register and save it when it was updated in memory.</p><h2 id=arm>ARM<a hidden class=anchor aria-hidden=true href=#arm>#</a></h2><p>On ARM specifically, you must enable interrupts on the peripheral. There is a configurable bit in the address space of the peripheral called the <em>interrupt enable</em>.</p><p>You also must configure the NVIC to accept interrupts. Finally, there is a global interrupt enable.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>