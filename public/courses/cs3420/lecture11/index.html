<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 11: Time Sharing | Jiming Chen</title><meta name=keywords content><meta name=description content="Context Switching
If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.
In order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.
What does the CPU need to execute a program the same way at two different times? We would need at least"><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs3420/lecture11/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs3420/lecture11/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs3420/lecture11/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 11: Time Sharing"><meta property="og:description" content="Context Switching If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.
In order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.
What does the CPU need to execute a program the same way at two different times? We would need at least"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-27T13:30:20-05:00"><meta property="article:modified_time" content="2025-02-27T13:30:20-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 11: Time Sharing"><meta name=twitter:description content="Context Switching
If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.
In order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.
What does the CPU need to execute a program the same way at two different times? We would need at least"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 3420: Embedded Systems","item":"https://jiming-chen.github.io/courses/cs3420/"},{"@type":"ListItem","position":3,"name":"Lecture 11: Time Sharing","item":"https://jiming-chen.github.io/courses/cs3420/lecture11/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 11: Time Sharing","name":"Lecture 11: Time Sharing","description":"Context Switching If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.\nIn order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.\nWhat does the CPU need to execute a program the same way at two different times? We would need at least\n","keywords":[],"articleBody":"Context Switching If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.\nIn order to do this, we need to stop programs and switch very quickly. We refer to running programs as processes.\nWhat does the CPU need to execute a program the same way at two different times? We would need at least\nRegisters Processor flags Configuration of peripheral devices Variables stored in memory Context switches are different from interrupts because user code doesn’t know it is inside an interrupt body, so it doesn’t know to restore the previous state. Contexts are stored in the stack.\nThe OS/scheduler maintains a queue of processes, implemented using linked lists. A round-robin scheduler continuously runs the process at the front of the queue then moves it to the back.\nThe process control block (PCB) is the unit that contains the context. It should include scheduling state, stack pointer, and a pointer to the next PCB. To store variables, you can use structs.\nIn order to switch contexts from A to B, we save A’s SP into A’s context, then switch the SP to B’s SP. To switch back, we can run POP PC.\nVirtual Memory Every context has the same memory layout, but these translate to to different areas in storage. This also prevents processes from accessing memory that isn’t theirs. However, this can be difficult to implement.\nScheduling There are several options we have for scheduling. One is first-come first-server (FCFS). It is non-preemptive, meaning each program runs until it voluntarily gives up the CPU. This is easy to implement because we don’t have to force it to switch contexts, but at the same time, if there is a bug or infinite loop, one process can affect the other processes.\nRound-robin (RR) scheduling cuts each process into chunks. This is an example of preemptive scheduling.\n","wordCount":"339","inLanguage":"en","datePublished":"2025-02-27T13:30:20-05:00","dateModified":"2025-02-27T13:30:20-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs3420/lecture11/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 11: Time Sharing</h1><div class=post-meta><span title='2025-02-27 13:30:20 -0500 EST'>February 27, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context-switching>Context Switching</a></li><li><a href=#virtual-memory>Virtual Memory</a></li><li><a href=#scheduling>Scheduling</a></li></ul></nav></div></details></div><div class=post-content><h2 id=context-switching>Context Switching<a hidden class=anchor aria-hidden=true href=#context-switching>#</a></h2><p>If you open task manager, you will see hundreds of processes running all running at the same time. There is the illusion that there is a CPU dedicated to each program, but in reality, all of them have to time share on a single CPU.</p><p>In order to do this, we need to stop programs and switch very quickly. We refer to running programs as <em>processes</em>.</p><p>What does the CPU need to execute a program the same way at two different times? We would need at least</p><ul><li>Registers</li><li>Processor flags</li><li>Configuration of peripheral devices</li><li>Variables stored in memory</li></ul><p>Context switches are different from interrupts because user code doesn&rsquo;t know it is inside an interrupt body, so it doesn&rsquo;t know to restore the previous state. Contexts are stored in the stack.</p><p>The OS/scheduler maintains a queue of processes, implemented using linked lists. A round-robin scheduler continuously runs the process at the front of the queue then moves it to the back.</p><p>The <em>process control block</em> (PCB) is the unit that contains the context. It should include scheduling state, stack pointer, and a pointer to the next PCB. To store variables, you can use structs.</p><p>In order to switch contexts from A to B, we save A&rsquo;s SP into A&rsquo;s context, then switch the SP to B&rsquo;s SP. To switch back, we can run <code>POP PC</code>.</p><h2 id=virtual-memory>Virtual Memory<a hidden class=anchor aria-hidden=true href=#virtual-memory>#</a></h2><p>Every context has the same memory layout, but these translate to to different areas in storage. This also prevents processes from accessing memory that isn&rsquo;t theirs. However, this can be difficult to implement.</p><h2 id=scheduling>Scheduling<a hidden class=anchor aria-hidden=true href=#scheduling>#</a></h2><p>There are several options we have for scheduling. One is <em>first-come first-server</em> (FCFS). It is non-preemptive, meaning each program runs until it voluntarily gives up the CPU. This is easy to implement because we don&rsquo;t have to force it to switch contexts, but at the same time, if there is a bug or infinite loop, one process can affect the other processes.</p><p><em>Round-robin</em> (RR) scheduling cuts each process into chunks. This is an example of preemptive scheduling.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>