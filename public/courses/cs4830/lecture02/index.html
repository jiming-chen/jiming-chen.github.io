<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 2: Semantic Security | Jiming Chen</title><meta name=keywords content><meta name=description content="Perfect Indistinguishability
It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \geq |M|$.
To prove this, we can choose an $m \in M$ and $c \in C$ such that $c$ is valid, e.g.
$$\text{Pr}[\text{Enc}(k, m) = c] > 0.$$
We can define $M_c := \{ m^\prime \in M : \exists k^\prime \in K \text{ s.t. } \text{Dec}(k^\prime, c) = m^\prime \}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \leq |K|$ since each key for which there is a message $m^\prime \in M_c$ can correspond to at most one such message."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4830/lecture02/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4830/lecture02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4830/lecture02/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 2: Semantic Security"><meta property="og:description" content="Perfect Indistinguishability It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \geq |M|$.
To prove this, we can choose an $m \in M$ and $c \in C$ such that $c$ is valid, e.g.
$$\text{Pr}[\text{Enc}(k, m) = c] > 0.$$
We can define $M_c := \{ m^\prime \in M : \exists k^\prime \in K \text{ s.t. } \text{Dec}(k^\prime, c) = m^\prime \}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \leq |K|$ since each key for which there is a message $m^\prime \in M_c$ can correspond to at most one such message."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-08-28T13:31:36-04:00"><meta property="article:modified_time" content="2025-08-28T13:31:36-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 2: Semantic Security"><meta name=twitter:description content="Perfect Indistinguishability
It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \geq |M|$.
To prove this, we can choose an $m \in M$ and $c \in C$ such that $c$ is valid, e.g.
$$\text{Pr}[\text{Enc}(k, m) = c] > 0.$$
We can define $M_c := \{ m^\prime \in M : \exists k^\prime \in K \text{ s.t. } \text{Dec}(k^\prime, c) = m^\prime \}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \leq |K|$ since each key for which there is a message $m^\prime \in M_c$ can correspond to at most one such message."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4830: Introduction to Cryptography","item":"https://jiming-chen.github.io/courses/cs4830/"},{"@type":"ListItem","position":3,"name":"Lecture 2: Semantic Security","item":"https://jiming-chen.github.io/courses/cs4830/lecture02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 2: Semantic Security","name":"Lecture 2: Semantic Security","description":"Perfect Indistinguishability It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \\geq |M|$.\nTo prove this, we can choose an $m \\in M$ and $c \\in C$ such that $c$ is valid, e.g.\n$$\\text{Pr}[\\text{Enc}(k, m) = c] \u0026gt; 0.$$\nWe can define $M_c := \\{ m^\\prime \\in M : \\exists k^\\prime \\in K \\text{ s.t. } \\text{Dec}(k^\\prime, c) = m^\\prime \\}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \\leq |K|$ since each key for which there is a message $m^\\prime \\in M_c$ can correspond to at most one such message.\n","keywords":[],"articleBody":"Perfect Indistinguishability It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \\geq |M|$.\nTo prove this, we can choose an $m \\in M$ and $c \\in C$ such that $c$ is valid, e.g.\n$$\\text{Pr}[\\text{Enc}(k, m) = c] \u003e 0.$$\nWe can define $M_c := \\{ m^\\prime \\in M : \\exists k^\\prime \\in K \\text{ s.t. } \\text{Dec}(k^\\prime, c) = m^\\prime \\}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \\leq |K|$ since each key for which there is a message $m^\\prime \\in M_c$ can correspond to at most one such message.\nBy perfect indistinguishability, $|M| = |M_c|$, so $|M| \\leq |K|$, and we are done.\nBecause of this, perfect indistinguishability is too restrictive, so we want a looser definition of semantic security.\nOther Definitions One-Message Perfect Semantic Security Now, we can define an encrytion scheme as being “one-message perfectly semantically secure” if for ANY adversary $\\mathcal{A}$, $\\text{Pr}[\\mathcal{A} \\text{ wins}] \\leq 1/2$, where the game is that the adversary sends to plaintexts to the challenger, the challenger encrypts both and randomly chooses one, and the adversary tries to guess which plaintext was chosen. This criterion is equivalent to perfect indistinguishability but it has the adversary in play.\nMany-Message Perfect Semantic Security What about “many-message perfect semantic security”? This time, we can allow the adversary to send two lists of plaintexts of length $\\ell$ decided by the adversary. If the adversary can guess a bit from the correct list of ciphertexts with probability at most $1/2$, then it is many-message perfectly semantically secure. It turns out that this definition is vacuous, as no such encryption scheme exists, and we actually proved this above.\nSo what is a better definition for semantic security? First, we should be okay with $|M_c| \\leq |M|$ because although an adversary can gain some information about what the plaintext could be for a cyphertext (e.g. win with probability slightly above $1/2$), we can assume that the adversary has a computational bound (probabilistic, polynomial-time).\nWe set a security parameter $n$ for the adversary to be consistent with efficiency in other areas of theoreticaly computer science. Basically, adversaries with higher security parameters are more powerful. Then, we can say that the adversary runs in polynomial time on $n$ if and only if the adversary is PPT.\nWe must also have the encryption scheme run in PPT.\nSide note: at this point, we should say $k \\leftarrow \\text{Gen}(1^n)$.\nSuper Many-Message Semantic Security So how about making an encryption scheme “super many-message semantically secure” if for any PPT adversary $\\mathcal{A}$ such that $\\text{Pr}[\\mathcal{A}(1^n) \\text{ wins}] \\leq 1/2$.\nThis turns out to be too strong (no encryption scheme exists) because an adversary can guess a key and compare the return from the challenger to one of the two plaintexts. Although it’s not immediately obvious that this gives the adversary a slight advantage, it does.\nMany-Message Semantic Security Now, we arrive at our last definition (“many-message semantic security”), whereby if for any PPT adversary $\\mathcal{A}$, there exists a negligible $\\epsilon(n)$ such that for all $n$,\n$$\\text{Pr}[\\mathcal{A}(1^n) \\text{ wins}] \\leq 1/2 + \\epsilon(n).$$\nThe motivation behind this is that negligible functions are eventually smaller than any (inverse) polynomial function, meaning PPT adversaries cannot take advantage of negligible advantages.\nIt will also be useful to us to define non-negligibility. A function $\\epsilon : \\mathbb{N} \\to \\mathbb{R}$ is non-negligible if there exists a positive integer $c$ such that $|\\epsilon(n)| \\geq n^{-c}$ for infinitely many values of $n$.\nA rule of thumb that we can use is that a PPT algorithm will never see an event that happens with negligible probability.\nAt the end of the day, many-message semantic security is a working definition for semantic security of secret-key encryption. However, it is somewhat complex: three messages go back and forth between the adversarity and the challenger (two lists of plaintexts, a list of cyphertexts, and a bit), and we need PPT and negligibility. But we will develop the tools to be able to construct an encryption scheme such that no PPT adversary has non-negligible advantage in distinguishing $\\text{Enc}(m_0)$ from $\\text{Enc}(m_1)$.\n","wordCount":"686","inLanguage":"en","datePublished":"2025-08-28T13:31:36-04:00","dateModified":"2025-08-28T13:31:36-04:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4830/lecture02/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 2: Semantic Security</h1><div class=post-meta><span title='2025-08-28 13:31:36 -0400 EDT'>August 28, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#perfect-indistinguishability>Perfect Indistinguishability</a></li><li><a href=#other-definitions>Other Definitions</a><ul><li><a href=#one-message-perfect-semantic-security>One-Message Perfect Semantic Security</a></li><li><a href=#many-message-perfect-semantic-security>Many-Message Perfect Semantic Security</a></li><li><a href=#super-many-message-semantic-security>Super Many-Message Semantic Security</a></li><li><a href=#many-message-semantic-security>Many-Message Semantic Security</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=perfect-indistinguishability>Perfect Indistinguishability<a hidden class=anchor aria-hidden=true href=#perfect-indistinguishability>#</a></h2><p>It can be proven that if you have an encryption scheme that is perfectly indistinguishable, then $|K| \geq |M|$.</p><p>To prove this, we can choose an $m \in M$ and $c \in C$ such that $c$ is valid, e.g.</p><p>$$\text{Pr}[\text{Enc}(k, m) = c] > 0.$$</p><p>We can define $M_c := \{ m^\prime \in M : \exists k^\prime \in K \text{ s.t. } \text{Dec}(k^\prime, c) = m^\prime \}$, which is the set of messages that can encrypt to $c$. Importantly, $|M_c| \leq |K|$ since each key for which there is a message $m^\prime \in M_c$ can correspond to at most one such message.</p><p>By perfect indistinguishability, $|M| = |M_c|$, so $|M| \leq |K|$, and we are done.</p><p>Because of this, perfect indistinguishability is too restrictive, so we want a looser definition of semantic security.</p><h2 id=other-definitions>Other Definitions<a hidden class=anchor aria-hidden=true href=#other-definitions>#</a></h2><h3 id=one-message-perfect-semantic-security>One-Message Perfect Semantic Security<a hidden class=anchor aria-hidden=true href=#one-message-perfect-semantic-security>#</a></h3><p>Now, we can define an encrytion scheme as being &ldquo;one-message perfectly semantically secure&rdquo; if for ANY adversary $\mathcal{A}$, $\text{Pr}[\mathcal{A} \text{ wins}] \leq 1/2$, where the game is that the adversary sends to plaintexts to the challenger, the challenger encrypts both and randomly chooses one, and the adversary tries to guess which plaintext was chosen. This criterion is equivalent to perfect indistinguishability but it has the adversary in play.</p><h3 id=many-message-perfect-semantic-security>Many-Message Perfect Semantic Security<a hidden class=anchor aria-hidden=true href=#many-message-perfect-semantic-security>#</a></h3><p>What about &ldquo;many-message perfect semantic security&rdquo;? This time, we can allow the adversary to send two lists of plaintexts of length $\ell$ decided by the adversary. If the adversary can guess a bit from the correct list of ciphertexts with probability at most $1/2$, then it is many-message perfectly semantically secure. It turns out that this definition is vacuous, as no such encryption scheme exists, and we actually proved this above.</p><p>So what is a better definition for semantic security? First, we should be okay with $|M_c| \leq |M|$ because although an adversary can gain some information about what the plaintext could be for a cyphertext (e.g. win with probability slightly above $1/2$), we can assume that the adversary has a computational bound (probabilistic, polynomial-time).</p><p>We set a security parameter $n$ for the adversary to be consistent with efficiency in other areas of theoreticaly computer science. Basically, adversaries with higher security parameters are more powerful. Then, we can say that the adversary runs in polynomial time on $n$ if and only if the adversary is PPT.</p><p>We must also have the encryption scheme run in PPT.</p><p>Side note: at this point, we should say $k \leftarrow \text{Gen}(1^n)$.</p><h3 id=super-many-message-semantic-security>Super Many-Message Semantic Security<a hidden class=anchor aria-hidden=true href=#super-many-message-semantic-security>#</a></h3><p>So how about making an encryption scheme &ldquo;super many-message semantically secure&rdquo; if for any PPT adversary $\mathcal{A}$ such that $\text{Pr}[\mathcal{A}(1^n) \text{ wins}] \leq 1/2$.</p><p>This turns out to be too strong (no encryption scheme exists) because an adversary can guess a key and compare the return from the challenger to one of the two plaintexts. Although it&rsquo;s not immediately obvious that this gives the adversary a slight advantage, it does.</p><h3 id=many-message-semantic-security>Many-Message Semantic Security<a hidden class=anchor aria-hidden=true href=#many-message-semantic-security>#</a></h3><p>Now, we arrive at our last definition (&ldquo;many-message semantic security&rdquo;), whereby if for any PPT adversary $\mathcal{A}$, there exists a negligible $\epsilon(n)$ such that for all $n$,</p><p>$$\text{Pr}[\mathcal{A}(1^n) \text{ wins}] \leq 1/2 + \epsilon(n).$$</p><p>The motivation behind this is that negligible functions are eventually smaller than any (inverse) polynomial function, meaning PPT adversaries cannot take advantage of negligible advantages.</p><p>It will also be useful to us to define non-negligibility. A function $\epsilon : \mathbb{N} \to \mathbb{R}$ is <em>non-negligible</em> if there exists a positive integer $c$ such that $|\epsilon(n)| \geq n^{-c}$ for infinitely many values of $n$.</p><p>A rule of thumb that we can use is that a PPT algorithm will never see an event that happens with negligible probability.</p><p>At the end of the day, many-message semantic security is a working definition for semantic security of secret-key encryption. However, it is somewhat complex: three messages go back and forth between the adversarity and the challenger (two lists of plaintexts, a list of cyphertexts, and a bit), and we need PPT and negligibility. But we will develop the tools to be able to construct an encryption scheme such that no PPT adversary has non-negligible advantage in distinguishing $\text{Enc}(m_0)$ from $\text{Enc}(m_1)$.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>