<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 4: Convolution and Geometric Transformations | Jiming Chen</title><meta name=keywords content><meta name=description content="Convolution
Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.
We also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4670/lecture04/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4670/lecture04/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4670/lecture04/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 4: Convolution and Geometric Transformations"><meta property="og:description" content="Convolution Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.
We also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-01-29T13:28:09-05:00"><meta property="article:modified_time" content="2025-01-29T13:28:09-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 4: Convolution and Geometric Transformations"><meta name=twitter:description content="Convolution
Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.
We also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4670: Intro to Computer Vision","item":"https://jiming-chen.github.io/courses/cs4670/"},{"@type":"ListItem","position":3,"name":"Lecture 4: Convolution and Geometric Transformations","item":"https://jiming-chen.github.io/courses/cs4670/lecture04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 4: Convolution and Geometric Transformations","name":"Lecture 4: Convolution and Geometric Transformations","description":"Convolution Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.\nWe also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out.\n","keywords":[],"articleBody":"Convolution Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.\nWe also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out.\nFig. 1. Row of matrix for convolving a pixel in an image. Geometric Transformations Geoemtric transformations have the form\n$$\\begin{bmatrix} x^\\prime \\\\ y^\\prime \\end{bmatrix} = T\\left(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\right).$$\nOne example of a geometric transformation is zooming in, which is a common action people take. Another is rotation followed by translation.\nOne important concept is differentiating forward transformations and inverse transformations. Sometimes, transformations don’t map to certain positions, so doing the inverse results in blank spots.\nIf $(x,y)$ goes to $(x^\\prime, y^\\prime)$, then we can say $f^\\prime(x^\\prime, y^\\prime) = f(x,y)$. But must $x,y,x^\\prime,y^\\prime$ be integers? They don’t have to be, but we must somehow interpret non-integer results in a way to put them in an image with integer pixels.\nOne solution is nearest neighbor interpolation, in which pixels take on the value of the nearest output value. This method does not produce that great results.\nAnother solution is bilinear interpolation, in which we weight the four nearest pixels such that their weighted average is the output pixel:\n$$\\begin{aligned} g(x,y) =\u0026 Cf(x_l,y_l) \\\\ \u0026+ Bf(x_h,y_l) \\\\ \u0026+ Af(x_h,y_h) \\\\ \u0026+ Df(x_l,y_h), \\end{aligned}$$\nwhere $A,B,C,D$ are (normalized) rectangle areas.\nGaussian interpolation is another method.\nInterpolation can also be used for upscaling images. When using nearest neighbor interpolation, we will often see blocky effects. Bilinear interpolation works a lot better although it may seem blurry.\nWhat if we want to zoom out (downsample), e.g. by a factor of 2? One way to do this is to drop every other pixel, in which case interpolation is not needed. However, this can cause weird patterns to emerge, which we call aliasing. This happens because in the original image, there can be many thinly separated regions of different colors, and when pixels in between are removed, those separations could disappear. This also appears in signal processing when interpolation of a high frequency wave could cause us to infer a low frequency wave.\nThe solution to aliasing in signal processing is the Fourier transform, in which functions are decomposed into sines and cosines. We can do something similar by blurring (using Gaussian pre-filtering) the original image to preserve the relations between dark and light pixels.\nOne neat thing we can do with this is blurring then subsampling repeatedly to get different information about the image.\n","wordCount":"477","inLanguage":"en","datePublished":"2025-01-29T13:28:09-05:00","dateModified":"2025-01-29T13:28:09-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4670/lecture04/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 4: Convolution and Geometric Transformations</h1><div class=post-meta><span title='2025-01-29 13:28:09 -0500 EST'>January 29, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#convolution>Convolution</a></li><li><a href=#geometric-transformations>Geometric Transformations</a></li></ul></nav></div></details></div><div class=post-content><h2 id=convolution>Convolution<a hidden class=anchor aria-hidden=true href=#convolution>#</a></h2><p>Last class, we mentioned that we can use convolution to turn color images gray. To do this, we can treat a color image as three layers of grayscale images and use a three-layer kernel.</p><p>We also mentioned looking at 1D convolution as matrix multiplication. To extend this to 2 dimensions, we can simply put all the rows/columns of the image in one long column vector, doing the matrix multiplication, and unwrapping the long column vector back into an image. Although it requires thinking to squish the kernel and place it into the square matrix, it works out.</p><img src=/courses/cs4670/lecture04/matrix.png alt="Matrix for convlution" width=80% class=center><figcaption>Fig. 1. Row of matrix for convolving a pixel in an image.</figcaption><h2 id=geometric-transformations>Geometric Transformations<a hidden class=anchor aria-hidden=true href=#geometric-transformations>#</a></h2><p>Geoemtric transformations have the form</p><p>$$\begin{bmatrix}
x^\prime \\ y^\prime
\end{bmatrix} = T\left(\begin{bmatrix}
x \\ y
\end{bmatrix}\right).$$</p><p>One example of a geometric transformation is zooming in, which is a common action people take. Another is rotation followed by translation.</p><p>One important concept is differentiating forward transformations and inverse transformations. Sometimes, transformations don&rsquo;t map to certain positions, so doing the inverse results in blank spots.</p><p>If $(x,y)$ goes to $(x^\prime, y^\prime)$, then we can say $f^\prime(x^\prime, y^\prime) = f(x,y)$. But must $x,y,x^\prime,y^\prime$ be integers? They don&rsquo;t have to be, but we must somehow interpret non-integer results in a way to put them in an image with integer pixels.</p><p>One solution is nearest neighbor interpolation, in which pixels take on the value of the nearest output value. This method does not produce that great results.</p><p>Another solution is bilinear interpolation, in which we weight the four nearest pixels such that their weighted average is the output pixel:</p><p>$$\begin{aligned}
g(x,y) =& Cf(x_l,y_l) \\
&+ Bf(x_h,y_l) \\
&+ Af(x_h,y_h) \\
&+ Df(x_l,y_h),
\end{aligned}$$</p><p>where $A,B,C,D$ are (normalized) rectangle areas.</p><p>Gaussian interpolation is another method.</p><p>Interpolation can also be used for upscaling images. When using nearest neighbor interpolation, we will often see blocky effects. Bilinear interpolation works a lot better although it may seem blurry.</p><p>What if we want to zoom out (downsample), e.g. by a factor of 2? One way to do this is to drop every other pixel, in which case interpolation is not needed. However, this can cause weird patterns to emerge, which we call aliasing. This happens because in the original image, there can be many thinly separated regions of different colors, and when pixels in between are removed, those separations could disappear. This also appears in signal processing when interpolation of a high frequency wave could cause us to infer a low frequency wave.</p><p>The solution to aliasing in signal processing is the Fourier transform, in which functions are decomposed into sines and cosines. We can do something similar by blurring (using Gaussian pre-filtering) the original image to preserve the relations between dark and light pixels.</p><p>One neat thing we can do with this is blurring then subsampling repeatedly to get different information about the image.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>