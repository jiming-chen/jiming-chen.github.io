<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 6: Edge Detection and Clustering | Jiming Chen</title>
<meta name=keywords content><meta name=description content="Edge Detection
Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:
$$\begin{bmatrix} 1 \\ 2 \\ 1\end{bmatrix} * \begin{bmatrix} 1 & 0 & -1 \end{bmatrix} = \begin{bmatrix}
1 & 0 & -1 \\
2 & 0 & -2 \\
1 & 0 & -1
\end{bmatrix}.$$
This filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4670/lecture06/><link crossorigin=anonymous href=/assets/css/stylesheet.862d2ab5d22734725b747026f6cbcd72cf56acbcb80e88f95d22ca71d767e619.css integrity="sha256-hi0qtdInNHJbdHAm9svNcs9WrLy4Doj5XSLKcddn5hk=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4670/lecture06/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4670/lecture06/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 6: Edge Detection and Clustering"><meta property="og:description" content="Edge Detection Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:
$$\begin{bmatrix} 1 \\ 2 \\ 1\end{bmatrix} * \begin{bmatrix} 1 & 0 & -1 \end{bmatrix} = \begin{bmatrix} 1 & 0 & -1 \\ 2 & 0 & -2 \\ 1 & 0 & -1 \end{bmatrix}.$$
This filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-02-05T13:31:49-05:00"><meta property="article:modified_time" content="2025-02-05T13:31:49-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 6: Edge Detection and Clustering"><meta name=twitter:description content="Edge Detection
Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:
$$\begin{bmatrix} 1 \\ 2 \\ 1\end{bmatrix} * \begin{bmatrix} 1 & 0 & -1 \end{bmatrix} = \begin{bmatrix}
1 & 0 & -1 \\
2 & 0 & -2 \\
1 & 0 & -1
\end{bmatrix}.$$
This filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4670: Intro to Computer Vision","item":"https://jiming-chen.github.io/courses/cs4670/"},{"@type":"ListItem","position":3,"name":"Lecture 6: Edge Detection and Clustering","item":"https://jiming-chen.github.io/courses/cs4670/lecture06/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 6: Edge Detection and Clustering","name":"Lecture 6: Edge Detection and Clustering","description":"Edge Detection Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:\n$$\\begin{bmatrix} 1 \\\\ 2 \\\\ 1\\end{bmatrix} * \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1 \\\\ 2 \u0026amp; 0 \u0026amp; -2 \\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}.$$\nThis filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction.\n","keywords":[],"articleBody":"Edge Detection Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:\n$$\\begin{bmatrix} 1 \\\\ 2 \\\\ 1\\end{bmatrix} * \\begin{bmatrix} 1 \u0026 0 \u0026 -1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 0 \u0026 -1 \\\\ 2 \u0026 0 \u0026 -2 \\\\ 1 \u0026 0 \u0026 -1 \\end{bmatrix}.$$\nThis filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction.\nNon-Maximum Suppression Again, recall that in order to find edges, we want to find peaks in the derivative or gradient magnitude. In order to do this, we can pick a point $q$, and $g(q)$, the gradient, should point to the greatest change in intensity. Then, we can a linear approximation to find the intensities one step forward and backward from $q$. If $q$ is a local maximum (by a certain threshold), we include it in the edge.\nHysteresis Thresholding Sometimes, high thresholding can leave out some edge pixels while low thresholding can include noise. Therefore, we can start with a high threshold and lower the threshold in certain areas only to continue edges (which is a key property of images).\nAll of this is basically what “canny edge detection” does, which is available in many libraries. However, even with all of this, we still have two issues:\nTexture is included as edges. Some edges are low contrast. Clustering Before, we viewed segmentation as representing regions, but we could also view it as gropuing together points. One way to do this is to use $k$-means.\n$k$-means clustering assumes each group is a Gaussian with different means but the same standard deviation. Each Gaussian looks like\n$$P(x_i \\mid \\mu_j) \\propto e^{-\\frac{1}{2\\sigma^2} ||x_i-\\mu_j||^2}.$$\nAssuming we know all the means, we can assign each point to the nearest mean. If we know the clusters, we can find the mean by averaging the points in each cluster.\nThe problem, though, is that we don’t know either, so instead we randomly pick $k$ centers. Then, we iterate by assigning all points and recomputing the means, doing so over and over.\n","wordCount":"357","inLanguage":"en","datePublished":"2025-02-05T13:31:49-05:00","dateModified":"2025-02-05T13:31:49-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4670/lecture06/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 6: Edge Detection and Clustering</h1><div class=post-meta><span title='2025-02-05 13:31:49 -0500 EST'>February 5, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#edge-detection>Edge Detection</a><ul><li><a href=#non-maximum-suppression>Non-Maximum Suppression</a></li><li><a href=#hysteresis-thresholding>Hysteresis Thresholding</a></li></ul></li><li><a href=#clustering>Clustering</a></li></ul></nav></div></details></div><div class=post-content><h2 id=edge-detection>Edge Detection<a hidden class=anchor aria-hidden=true href=#edge-detection>#</a></h2><p>Recall that we can use anisotropic filtering because Gaussian filtering should not be the same in every direction. One variant of the anisotropic Gaussian is the Sobel filter:</p><p>$$\begin{bmatrix} 1 \\ 2 \\ 1\end{bmatrix} * \begin{bmatrix} 1 & 0 & -1 \end{bmatrix} = \begin{bmatrix}
1 & 0 & -1 \\
2 & 0 & -2 \\
1 & 0 & -1
\end{bmatrix}.$$</p><p>This filter first highlights differences between dark and light areas but then does a convolution in the $x$ direction.</p><h3 id=non-maximum-suppression>Non-Maximum Suppression<a hidden class=anchor aria-hidden=true href=#non-maximum-suppression>#</a></h3><p>Again, recall that in order to find edges, we want to find peaks in the derivative or gradient magnitude. In order to do this, we can pick a point $q$, and $g(q)$, the gradient, should point to the greatest change in intensity. Then, we can a linear approximation to find the intensities one step forward and backward from $q$. If $q$ is a local maximum (by a certain threshold), we include it in the edge.</p><h3 id=hysteresis-thresholding>Hysteresis Thresholding<a hidden class=anchor aria-hidden=true href=#hysteresis-thresholding>#</a></h3><p>Sometimes, high thresholding can leave out some edge pixels while low thresholding can include noise. Therefore, we can start with a high threshold and lower the threshold in certain areas only to continue edges (which is a key property of images).</p><p>All of this is basically what &ldquo;canny edge detection&rdquo; does, which is available in many libraries. However, even with all of this, we still have two issues:</p><ol><li>Texture is included as edges.</li><li>Some edges are low contrast.</li></ol><h2 id=clustering>Clustering<a hidden class=anchor aria-hidden=true href=#clustering>#</a></h2><p>Before, we viewed segmentation as representing regions, but we could also view it as gropuing together points. One way to do this is to use $k$-means.</p><p>$k$-means clustering assumes each group is a Gaussian with different means but the same standard deviation. Each Gaussian looks like</p><p>$$P(x_i \mid \mu_j) \propto e^{-\frac{1}{2\sigma^2} ||x_i-\mu_j||^2}.$$</p><p>Assuming we know all the means, we can assign each point to the nearest mean. If we know the clusters, we can find the mean by averaging the points in each cluster.</p><p>The problem, though, is that we don&rsquo;t know either, so instead we randomly pick $k$ centers. Then, we iterate by assigning all points and recomputing the means, doing so over and over.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>