<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 5: Grouping and Edges | Jiming Chen</title>
<meta name=keywords content><meta name=description content="Bilinear Interpolation Review
To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.
Grouping and Edges
Why grouping? As humans, when we see images or moving pictures, we don&rsquo;t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4670/lecture05/><link crossorigin=anonymous href=/assets/css/stylesheet.862d2ab5d22734725b747026f6cbcd72cf56acbcb80e88f95d22ca71d767e619.css integrity="sha256-hi0qtdInNHJbdHAm9svNcs9WrLy4Doj5XSLKcddn5hk=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4670/lecture05/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4670/lecture05/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 5: Grouping and Edges"><meta property="og:description" content="Bilinear Interpolation Review To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.
Grouping and Edges Why grouping? As humans, when we see images or moving pictures, we don’t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-01-31T13:28:07-05:00"><meta property="article:modified_time" content="2025-01-31T13:28:07-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 5: Grouping and Edges"><meta name=twitter:description content="Bilinear Interpolation Review
To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.
Grouping and Edges
Why grouping? As humans, when we see images or moving pictures, we don&rsquo;t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4670: Intro to Computer Vision","item":"https://jiming-chen.github.io/courses/cs4670/"},{"@type":"ListItem","position":3,"name":"Lecture 5: Grouping and Edges","item":"https://jiming-chen.github.io/courses/cs4670/lecture05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 5: Grouping and Edges","name":"Lecture 5: Grouping and Edges","description":"Bilinear Interpolation Review To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.\nGrouping and Edges Why grouping? As humans, when we see images or moving pictures, we don\u0026rsquo;t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing.\n","keywords":[],"articleBody":"Bilinear Interpolation Review To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.\nGrouping and Edges Why grouping? As humans, when we see images or moving pictures, we don’t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing.\nHow do we look for edges? We could say edges are curves in the image across which brightness changes a lot. However, lighting conditions may make it so that the brightness does not change a lot across it. There are several types of edges:\nDepth discontinuities Normal discontinuities Discontinuities in “paint” Shadows Fig. 1. Cylinder on checkerboard with edges. To find images, we can look at the intensity function along a line and find where it changes quickly, which is where the magnitude of the derivative is high. Importantly, differentiation is linear and shift-equivariant.\nBut how can we take a derivative of an image, which is discrete rather than continuous? We have two options:\nReconstruct a continuous function for the image. Compute a slope rather than a limit of a slope as the derivative. How would we implement the latter as a linear filter? We can do it like so in the $x$ direction:\n$$ \\begin{array}{|c|c|c|} \\hline 0 \u0026 0 \u0026 0 \\\\ \\hline 1 \u0026 -1 \u0026 0 \\\\ \\hline 0 \u0026 0 \u0026 0 \\\\ \\hline \\end{array} $$\nWe can do something similar for the $y$ direction.\nHow does noise affect edge detection? If the intensity function is noisy, then its derivative will be very spiky, and it won’t be clear where the edge is. The solution is to use a Gaussian to smooth out the image, and the edge will become more apparent.\nSince convolution is associative, we can use the fact that\n$$\\frac{d}{dx} (f * h) = f * \\frac{d}{dx} h,$$\nwhich can save on computation. However, as discussed in a previous lecture, the $\\sigma$ of the Gaussian changes what scale edges are detected, so we will later study how $\\sigma$ affects this.\nSo far, we have been doing the Gaussian in two dimensions. But should we be smoothing along the edge to the same degree that we smooth across it? In practice, probably not, which is why we use an anisotropic Gaussian which has a lower standard deviation along one direction.\n","wordCount":"424","inLanguage":"en","datePublished":"2025-01-31T13:28:07-05:00","dateModified":"2025-01-31T13:28:07-05:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4670/lecture05/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 5: Grouping and Edges</h1><div class=post-meta><span title='2025-01-31 13:28:07 -0500 EST'>January 31, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#bilinear-interpolation-review>Bilinear Interpolation Review</a></li><li><a href=#grouping-and-edges>Grouping and Edges</a></li></ul></nav></div></details></div><div class=post-content><h2 id=bilinear-interpolation-review>Bilinear Interpolation Review<a hidden class=anchor aria-hidden=true href=#bilinear-interpolation-review>#</a></h2><p>To perform bilinear interpolation, we could use the traditional area formula, or we could use one linear interpolation to find points on the edge that lie across from each other through the point of interest and perform another interpolation to get the value of the point we want.</p><h2 id=grouping-and-edges>Grouping and Edges<a hidden class=anchor aria-hidden=true href=#grouping-and-edges>#</a></h2><p>Why grouping? As humans, when we see images or moving pictures, we don&rsquo;t look at pixels, we see objects that the pixels represent. Therefore, it is useful to have computers do the same thing.</p><p>How do we look for edges? We could say edges are curves in the image across which brightness changes a lot. However, lighting conditions may make it so that the brightness does not change a lot across it. There are several types of edges:</p><ul><li>Depth discontinuities</li><li>Normal discontinuities</li><li>Discontinuities in &ldquo;paint&rdquo;</li><li>Shadows</li></ul><img src=/courses/cs4670/lecture05/checker.png alt="Checker shadow illusion" width=80% class=center><figcaption>Fig. 1. Cylinder on checkerboard with edges.</figcaption><p>To find images, we can look at the intensity function along a line and find where it changes quickly, which is where the magnitude of the derivative is high. Importantly, differentiation is linear and shift-equivariant.</p><p>But how can we take a derivative of an image, which is discrete rather than continuous? We have two options:</p><ul><li>Reconstruct a continuous function for the image.</li><li>Compute a slope rather than a limit of a slope as the derivative.</li></ul><p>How would we implement the latter as a linear filter? We can do it like so in the $x$ direction:</p><p>$$
\begin{array}{|c|c|c|}
\hline 0 & 0 & 0 \\
\hline 1 & -1 & 0 \\
\hline 0 & 0 & 0 \\
\hline
\end{array}
$$</p><p>We can do something similar for the $y$ direction.</p><p>How does noise affect edge detection? If the intensity function is noisy, then its derivative will be very spiky, and it won&rsquo;t be clear where the edge is. The solution is to use a Gaussian to smooth out the image, and the edge will become more apparent.</p><p>Since convolution is associative, we can use the fact that</p><p>$$\frac{d}{dx} (f * h) = f * \frac{d}{dx} h,$$</p><p>which can save on computation. However, as discussed in a previous lecture, the $\sigma$ of the Gaussian changes what scale edges are detected, so we will later study how $\sigma$ affects this.</p><p>So far, we have been doing the Gaussian in two dimensions. But should we be smoothing along the edge to the same degree that we smooth across it? In practice, probably not, which is why we use an anisotropic Gaussian which has a lower standard deviation along one direction.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>