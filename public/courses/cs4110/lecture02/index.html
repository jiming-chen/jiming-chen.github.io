<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 2: Introduction to Semantics | Jiming Chen</title><meta name=keywords content><meta name=description content="What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.
A simple language we could look at is that of arithmetic expressions with assignment.
First we establish some metavariables. We can establish $x, y, z \in \text{Var}$ (variables), let $n, m \in \text{Int}$ (integers), and let $e \in \text{Exp}$ (expressions)."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4110/lecture02/><link crossorigin=anonymous href=/assets/css/stylesheet.d20d31710e1e17ede7c7f9ededb138159f9228abc86b338e8d1053ed139865b7.css integrity="sha256-0g0xcQ4eF+3nx/nt7bE4FZ+SKKvIazOOjRBT7ROYZbc=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4110/lecture02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4110/lecture02/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 2: Introduction to Semantics"><meta property="og:description" content="What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.
A simple language we could look at is that of arithmetic expressions with assignment.
First we establish some metavariables. We can establish $x, y, z \in \text{Var}$ (variables), let $n, m \in \text{Int}$ (integers), and let $e \in \text{Exp}$ (expressions)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-08-27T10:12:50-04:00"><meta property="article:modified_time" content="2025-08-27T10:12:50-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 2: Introduction to Semantics"><meta name=twitter:description content="What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.
A simple language we could look at is that of arithmetic expressions with assignment.
First we establish some metavariables. We can establish $x, y, z \in \text{Var}$ (variables), let $n, m \in \text{Int}$ (integers), and let $e \in \text{Exp}$ (expressions)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4110: Programming Languages and Logics","item":"https://jiming-chen.github.io/courses/cs4110/"},{"@type":"ListItem","position":3,"name":"Lecture 2: Introduction to Semantics","item":"https://jiming-chen.github.io/courses/cs4110/lecture02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 2: Introduction to Semantics","name":"Lecture 2: Introduction to Semantics","description":"What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.\nA simple language we could look at is that of arithmetic expressions with assignment.\nFirst we establish some metavariables. We can establish $x, y, z \\in \\text{Var}$ (variables), let $n, m \\in \\text{Int}$ (integers), and let $e \\in \\text{Exp}$ (expressions).\n","keywords":[],"articleBody":"What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.\nA simple language we could look at is that of arithmetic expressions with assignment.\nFirst we establish some metavariables. We can establish $x, y, z \\in \\text{Var}$ (variables), let $n, m \\in \\text{Int}$ (integers), and let $e \\in \\text{Exp}$ (expressions).\nThe syntax of this language is given by the following BNF grammar:\n$$\\begin{aligned} e ::\u0026= x \\\\ \u0026|\\ n \\\\ \u0026|\\ e_1 + e_2 \\\\ \u0026|\\ e_1 * e_2 \\\\ \u0026|\\ x := e_1 \\ ; \\ e_2 \\end{aligned}$$\nThis describes a set of expressions that includes assignment and sequences.\nWe can look at expressions as trees (the last three options in the grammar would have multiple children). There can be multiple possible trees for an expression, but we will not worry about that in this course (it is dealt with in CS 4120).\nSuch a tree is called an abstract syntax tree and is the result of parsing. We may assume that the AST has already been achieved.\nIn languages like OCaml, construction of algebraic data types look very similar to the BNF grammar. In object oriented languages, we can use types and subtypes to implement the same thing.\nOperational Semantics Recall that operational semantics models programs by execution on an abstract machine and is useful for implementing interpreters and compilers.\nA small-step operational semantics describes how such an execution proceeds from configuration to configuration: $\\langle \\sigma, e \\rangle \\to \\langle \\sigma^\\prime, e^\\prime \\rangle$.\nA configuration $\\langle \\sigma, e \\rangle$ is a pair of a store $\\sigma$ that records the values of the variables and the expression $e$ being evaluated. More precisely, a store is a partial function from variables to integers:\n$$\\begin{aligned} \\text{Store} \u0026\\triangleq \\text{Var} \\rightharpoonup \\text{Int} \\\\ \\text{Config} \u0026\\triangleq \\text{Store} \\times \\text{Ex}. \\end{aligned}$$\nThe small-step operational semantics itself is a relation on configurations because we can relate different configurations to each other:\n$$(\\langle \\sigma, e \\rangle, \\langle \\sigma^\\prime, e^\\prime \\rangle) \\in “\\rightarrow”.$$\nSo how do we define this relation? It seems difficult because the set of configurations is infinite, but we can define if inductively using inference rules:\n$$\\frac{\\text{premise}_1 \\quad \\text{premise}_2 \\quad \\cdots}{\\text{conclusion}} \\text{NAME}.$$\nThis is basically a big if statement; if all the premises hold, then the conclusion also holds.\nFormally, “$\\rightarrow$” is the smallest relation that is closed under all the inference rules.\nHere is an example inference rule for our arithmetic case:\n$$\\frac{p = m + n}{\\langle \\sigma, n + m \\rangle \\rightarrow \\langle \\sigma, p\\rangle} \\text{ADD}.$$\nNote that for addition, this is not sufficient; we need rules that transition between configurations that have sums of expressions and expressions as well as integers and expressions. Those are called congruence rules.\nFor assignments, the premise is $\\sigma^\\prime = \\sigma[x \\mapsto n]$.\n","wordCount":"481","inLanguage":"en","datePublished":"2025-08-27T10:12:50-04:00","dateModified":"2025-08-27T10:12:50-04:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4110/lecture02/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 2: Introduction to Semantics</h1><div class=post-meta><span title='2025-08-27 10:12:50 -0400 EDT'>August 27, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#operational-semantics>Operational Semantics</a></li></ul></nav></div></details></div><div class=post-content><p>What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.</p><p>A simple language we could look at is that of arithmetic expressions with assignment.</p><p>First we establish some metavariables. We can establish $x, y, z \in \text{Var}$ (variables), let $n, m \in \text{Int}$ (integers), and let $e \in \text{Exp}$ (expressions).</p><p>The syntax of this language is given by the following BNF grammar:</p><p>$$\begin{aligned}
e ::&= x \\
&|\ n \\
&|\ e_1 + e_2 \\
&|\ e_1 * e_2 \\
&|\ x := e_1 \ ; \ e_2
\end{aligned}$$</p><p>This describes a set of expressions that includes assignment and sequences.</p><p>We can look at expressions as trees (the last three options in the grammar would have multiple children). There can be multiple possible trees for an expression, but we will not worry about that in this course (it is dealt with in CS 4120).</p><p>Such a tree is called an <em>abstract syntax tree</em> and is the result of parsing. We may assume that the AST has already been achieved.</p><p>In languages like OCaml, construction of algebraic data types look very similar to the BNF grammar. In object oriented languages, we can use types and subtypes to implement the same thing.</p><h2 id=operational-semantics>Operational Semantics<a hidden class=anchor aria-hidden=true href=#operational-semantics>#</a></h2><p>Recall that operational semantics models programs by execution on an abstract machine and is useful for implementing interpreters and compilers.</p><p>A small-step operational semantics describes how such an execution proceeds from configuration to configuration: $\langle \sigma, e \rangle \to \langle \sigma^\prime, e^\prime \rangle$.</p><p>A <em>configuration</em> $\langle \sigma, e \rangle$ is a pair of a <em>store</em> $\sigma$ that records the values of the variables and the <em>expression</em> $e$ being evaluated. More precisely, a store is a partial function from variables to integers:</p><p>$$\begin{aligned}
\text{Store} &\triangleq \text{Var} \rightharpoonup \text{Int} \\
\text{Config} &\triangleq \text{Store} \times \text{Ex}.
\end{aligned}$$</p><p>The small-step operational semantics itself is a relation on configurations because we can relate different configurations to each other:</p><p>$$(\langle \sigma, e \rangle, \langle \sigma^\prime, e^\prime \rangle) \in &ldquo;\rightarrow&rdquo;.$$</p><p>So how do we define this relation? It seems difficult because the set of configurations is infinite, but we can define if inductively using <em>inference rules</em>:</p><p>$$\frac{\text{premise}_1 \quad \text{premise}_2 \quad \cdots}{\text{conclusion}} \text{NAME}.$$</p><p>This is basically a big if statement; if all the <em>premises</em> hold, then the <em>conclusion</em> also holds.</p><p>Formally, &ldquo;$\rightarrow$&rdquo; is the smallest relation that is closed under all the inference rules.</p><p>Here is an example inference rule for our arithmetic case:</p><p>$$\frac{p = m + n}{\langle \sigma, n + m \rangle \rightarrow \langle \sigma, p\rangle} \text{ADD}.$$</p><p>Note that for addition, this is not sufficient; we need rules that transition between configurations that have sums of expressions and expressions as well as integers and expressions. Those are called <em>congruence rules</em>.</p><p>For assignments, the premise is $\sigma^\prime = \sigma[x \mapsto n]$.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>