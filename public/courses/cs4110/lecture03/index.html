<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 3: Induction | Jiming Chen</title><meta name=keywords content><meta name=description content="Inference Rules
Suppose that $\sigma$ is some store that maps foo to 4. Consider $\langle \sigma, (\texttt{foo} + 2) \times (\texttt{bar} + 1)\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the &ldquo;final&rdquo; configuration:"><meta name=author content="Jiming Chen"><link rel=canonical href=http://localhost:1313/courses/cs4110/lecture03/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icons/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icons/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/courses/cs4110/lecture03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="http://localhost:1313/courses/cs4110/lecture03/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 3: Induction"><meta property="og:description" content="Inference Rules Suppose that $\sigma$ is some store that maps foo to 4. Consider $\langle \sigma, (\texttt{foo} + 2) \times (\texttt{bar} + 1)\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the “final” configuration:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-08-29T10:09:31-04:00"><meta property="article:modified_time" content="2025-08-29T10:09:31-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 3: Induction"><meta name=twitter:description content="Inference Rules
Suppose that $\sigma$ is some store that maps foo to 4. Consider $\langle \sigma, (\texttt{foo} + 2) \times (\texttt{bar} + 1)\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the &ldquo;final&rdquo; configuration:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"http://localhost:1313/courses/"},{"@type":"ListItem","position":2,"name":"CS 4110: Programming Languages and Logics","item":"http://localhost:1313/courses/cs4110/"},{"@type":"ListItem","position":3,"name":"Lecture 3: Induction","item":"http://localhost:1313/courses/cs4110/lecture03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 3: Induction","name":"Lecture 3: Induction","description":"Inference Rules Suppose that $\\sigma$ is some store that maps foo to 4. Consider $\\langle \\sigma, (\\texttt{foo} + 2) \\times (\\texttt{bar} + 1)\\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the \u0026ldquo;final\u0026rdquo; configuration:\n","keywords":[],"articleBody":"Inference Rules Suppose that $\\sigma$ is some store that maps foo to 4. Consider $\\langle \\sigma, (\\texttt{foo} + 2) \\times (\\texttt{bar} + 1)\\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the “final” configuration:\nFig. 1. The proof tree for the expression $\\langle \\sigma, (\\texttt{foo} + 2) \\times (\\texttt{bar} + 1)\\rangle$ if $\\sigma$ maps `foo` to `4`. Note that we conventionally say that there is only one step from the original configuration to the evaluated configuration since the “substeps” only help us navigate to the final configuration. To do this, we define a multi-step relation, written $\\rightarrow^*$. With $\\rightarrow^*$, we can step with reflexive and transitive closure:\n$$\\frac{}{\\langle\\sigma, e\\rangle \\rightarrow^* \\langle \\sigma, e\\rangle} \\text{REFL}, \\quad \\frac{\\langle \\sigma, e\\rangle \\rightarrow \\langle \\sigma^\\prime, e^\\prime \\rangle \\quad \\langle \\sigma^\\prime, e^\\prime\\rangle \\rightarrow^* \\langle \\sigma^{\\prime\\prime}, e^{\\prime\\prime}\\rangle}{\\langle \\sigma, e\\rangle \\rightarrow^* \\langle \\sigma^{\\prime\\prime}, e^{\\prime\\prime}\\rangle} \\text{TRANS}.$$\nOne can prove that something is in the reflexive relation if and only if it is in the transitive relation (not sure if he actually said this).\nProperties There are several properties a semantics could have that are provable by induction:\nDeterminism: Every configuration has at most one successor. Termination: Evaluation of every expression terminates. Soundness: Evaluation of every expression yields an integer. Our arithmetic language satisfies the first determinism and termination, but if it gets stuck with unbound variables, it may not satisfy soundness.\nTherefore, we might be interested in restricting ourselves to well-formed configurations $\\langle \\sigma, e\\rangle$, where all the free variables that $e$ refers to have values in $\\sigma$.\n$$\\begin{aligned} fvs(x) \u0026\\triangleq \\{x\\} \\\\ fvs(n) \u0026\\triangleq \\{\\} \\\\ fvs(e_1 + e_2) \u0026\\triangleq fvs(e_1) \\cup fvs(e_2) \\\\ fvs(e_1 * e_2) \u0026\\triangleq fvs(e_1) \\cup fvs(e_2) \\\\ fvs(x := e_1 ; e_2) \u0026\\triangleq fvs(e_1) \\cup fvs(e_2) \\setminus \\{x\\} \\\\ \\end{aligned}$$\nIf we have a well-formed configuration, we can formulate two properties that imply soundness:\nProgress: there is always a step that that can be taken Preservation: every step preserves well-formedness Inductive Sets An inductively-defined set $A$ is one that can be described using a finite collection of inference rules. For a rule\n$$\\frac{a_1 \\in A \\quad \\cdots \\quad a_n \\in A}{a \\in A},$$\nif $a_1, \\dots a_n \\in A$, then $a \\in A$.\nIf there are no premises, then the conclusion is an axiom.\nThe small-step evaluation relation we just defined, $\\rightarrow$, is an inductive set.\nNow, note that every BNF grammar defines an inductive set. However, we use BNF grammars because they are more concise.\nTo write the natural numbers as an inductive set, we may write the following:\n$$\\frac{}{0 \\in \\mathbb{N}} \\quad \\frac{n \\in \\mathbb{N}}{succ(n) \\in \\mathbb{N}}.$$\nWe may revisit inductive proofs from the world of inductive sets. We may do inductive proofs on the way an inductive set steps or on the actual structure of $e$. They may b esimilar, but sometimes one is easier than the other.\nTo actually do the proof, if we have a property $P$, we should prove it on the axioms as well as for each inference rule (proving that if $P$ holds for each premise, then it holds for the conclusion).\nWe can prove progress by structural induction on $e$.\nHere is a proof outline for proving progress on any expression $e$ in our arithmetic example.\nWe have five rules to prove the property for.\nFor\n$$\\frac{}{x \\in \\text{Exp}},$$\nfor any $\\sigma$, assume $wf(\\sigma, e)$ (wf means well-founded). Therefore, $fvs(x) = \\{x\\} \\subseteq \\text{dom}(\\sigma)$.\nThen, by the $\\text{Var}$ rule, for any $n$, we if $\\sigma(x) = n$, we can step from $\\langle \\sigma, e\\rangle$ can step to $\\langle \\sigma, n\\rangle$, which means there exists $ \\sigma^\\prime, e^\\prime$ such that $\\langle \\sigma, e\\rangle \\to \\langle \\sigma^\\prime, e^\\prime\\rangle$.\n","wordCount":"639","inLanguage":"en","datePublished":"2025-08-29T10:09:31-04:00","dateModified":"2025-08-29T10:09:31-04:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/courses/cs4110/lecture03/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=http://localhost:1313/posts/ title=Blog><span>Blog</span></a></li><li><a href=http://localhost:1313/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 3: Induction</h1><div class=post-meta><span title='2025-08-29 10:09:31 -0400 EDT'>August 29, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#inference-rules>Inference Rules</a></li><li><a href=#properties>Properties</a></li><li><a href=#inductive-sets>Inductive Sets</a></li></ul></nav></div></details></div><div class=post-content><h2 id=inference-rules>Inference Rules<a hidden class=anchor aria-hidden=true href=#inference-rules>#</a></h2><p>Suppose that $\sigma$ is some store that maps <code>foo</code> to <code>4</code>. Consider $\langle \sigma, (\texttt{foo} + 2) \times (\texttt{bar} + 1)\rangle$. In this case, the only inference rule that applies here is the one that allows the left side of the product to take a step. Doing this repeatedly results in a proof tree which shows how we can go from the original configuration to the &ldquo;final&rdquo; configuration:</p><img src=/courses/cs4110/inference.png alt="Proof tree" width=80% class=center><figcaption>Fig. 1. The proof tree for the expression $\langle \sigma, (\texttt{foo} + 2) \times (\texttt{bar} + 1)\rangle$ if $\sigma$ maps `foo` to `4`.</figcaption><p>Note that we conventionally say that there is only one step from the original configuration to the evaluated configuration since the &ldquo;substeps&rdquo; only help us navigate to the final configuration. To do this, we define a multi-step relation, written $\rightarrow^*$. With $\rightarrow^*$, we can step with reflexive and transitive closure:</p><p>$$\frac{}{\langle\sigma, e\rangle \rightarrow^* \langle \sigma, e\rangle} \text{REFL}, \quad \frac{\langle \sigma, e\rangle \rightarrow \langle \sigma^\prime, e^\prime \rangle \quad \langle \sigma^\prime, e^\prime\rangle \rightarrow^* \langle \sigma^{\prime\prime}, e^{\prime\prime}\rangle}{\langle \sigma, e\rangle \rightarrow^* \langle \sigma^{\prime\prime}, e^{\prime\prime}\rangle} \text{TRANS}.$$</p><p>One can prove that something is in the reflexive relation if and only if it is in the transitive relation (not sure if he actually said this).</p><h2 id=properties>Properties<a hidden class=anchor aria-hidden=true href=#properties>#</a></h2><p>There are several properties a semantics could have that are provable by induction:</p><ul><li>Determinism: Every configuration has at most one successor.</li><li>Termination: Evaluation of every expression terminates.</li><li>Soundness: Evaluation of every expression yields an integer.</li></ul><p>Our arithmetic language satisfies the first determinism and termination, but if it gets stuck with unbound variables, it may not satisfy soundness.</p><p>Therefore, we might be interested in restricting ourselves to <em>well-formed</em> configurations $\langle \sigma, e\rangle$, where all the free variables that $e$ refers to have values in $\sigma$.</p><p>$$\begin{aligned}
fvs(x) &\triangleq \{x\} \\
fvs(n) &\triangleq \{\} \\
fvs(e_1 + e_2) &\triangleq fvs(e_1) \cup fvs(e_2) \\
fvs(e_1 * e_2) &\triangleq fvs(e_1) \cup fvs(e_2) \\
fvs(x := e_1 ; e_2) &\triangleq fvs(e_1) \cup fvs(e_2) \setminus \{x\} \\
\end{aligned}$$</p><p>If we have a well-formed configuration, we can formulate two properties that imply soundness:</p><ul><li>Progress: there is always a step that that can be taken</li><li>Preservation: every step preserves well-formedness</li></ul><h2 id=inductive-sets>Inductive Sets<a hidden class=anchor aria-hidden=true href=#inductive-sets>#</a></h2><p>An <em>inductively-defined set</em> $A$ is one that can be described using a finite collection of inference rules. For a rule</p><p>$$\frac{a_1 \in A \quad \cdots \quad a_n \in A}{a \in A},$$</p><p>if $a_1, \dots a_n \in A$, then $a \in A$.</p><p>If there are no premises, then the conclusion is an axiom.</p><p>The small-step evaluation relation we just defined, $\rightarrow$, is an inductive set.</p><p>Now, note that every BNF grammar defines an inductive set. However, we use BNF grammars because they are more concise.</p><p>To write the natural numbers as an inductive set, we may write the following:</p><p>$$\frac{}{0 \in \mathbb{N}} \quad \frac{n \in \mathbb{N}}{succ(n) \in \mathbb{N}}.$$</p><p>We may revisit inductive proofs from the world of inductive sets. We may do inductive proofs on the way an inductive set steps or on the actual structure of $e$. They may b esimilar, but sometimes one is easier than the other.</p><p>To actually do the proof, if we have a property $P$, we should prove it on the axioms as well as for each inference rule (proving that if $P$ holds for each premise, then it holds for the conclusion).</p><p>We can prove progress by structural induction on $e$.</p><p>Here is a proof outline for proving progress on any expression $e$ in our arithmetic example.</p><p>We have five rules to prove the property for.</p><p>For</p><p>$$\frac{}{x \in \text{Exp}},$$</p><p>for any $\sigma$, assume $wf(\sigma, e)$ (<code>wf</code> means well-founded). Therefore, $fvs(x) = \{x\} \subseteq \text{dom}(\sigma)$.</p><p>Then, by the $\text{Var}$ rule, for any $n$, we if $\sigma(x) = n$, we can step from $\langle \sigma, e\rangle$ can step to $\langle \sigma, n\rangle$, which means there exists $ \sigma^\prime, e^\prime$ such that $\langle \sigma, e\rangle \to \langle \sigma^\prime, e^\prime\rangle$.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>