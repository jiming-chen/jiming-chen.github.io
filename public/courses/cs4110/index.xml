<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS 4110: Programming Languages and Logics on Jiming Chen</title>
    <link>https://jiming-chen.github.io/courses/cs4110/</link>
    <description>Recent content in CS 4110: Programming Languages and Logics on Jiming Chen</description>
    <generator>Hugo -- 0.149.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 27 Aug 2025 10:12:50 -0400</lastBuildDate>
    <atom:link href="https://jiming-chen.github.io/courses/cs4110/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lecture 2: Introduction to Semantics</title>
      <link>https://jiming-chen.github.io/courses/cs4110/lecture02/</link>
      <pubDate>Wed, 27 Aug 2025 10:12:50 -0400</pubDate>
      <guid>https://jiming-chen.github.io/courses/cs4110/lecture02/</guid>
      <description>&lt;p&gt;What is the meaning of a program? We could execute the program or consult a manual, but these are not satisfactory approaches because the program could execution could not work and manuals are not speciic.&lt;/p&gt;
&lt;p&gt;A simple language we could look at is that of arithmetic expressions with assignment.&lt;/p&gt;
&lt;p&gt;First we establish some metavariables. We can establish $x, y, z \in \text{Var}$ (variables), let $n, m \in \text{Int}$ (integers), and let $e \in \text{Exp}$ (expressions).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lecture 1: Course Overview</title>
      <link>https://jiming-chen.github.io/courses/cs4110/lecture01/</link>
      <pubDate>Mon, 25 Aug 2025 10:08:42 -0400</pubDate>
      <guid>https://jiming-chen.github.io/courses/cs4110/lecture01/</guid>
      <description>&lt;p&gt;This lecture serves as theater, e.g. to show why studying programming languages might be cool.&lt;/p&gt;
&lt;h2 id=&#34;programming-language-quirk-examples&#34;&gt;Programming Language Quirk Examples&lt;/h2&gt;
&lt;p&gt;One cool example of programming languages being weird is how &lt;code&gt;[] + []&lt;/code&gt;, &lt;code&gt;[] + {}&lt;/code&gt;, &lt;code&gt;{} + []&lt;/code&gt;, and &lt;code&gt;{} + {}&lt;/code&gt; all evaluate to different things in JavaScript.&lt;/p&gt;
&lt;p&gt;If we run &lt;code&gt;a = [1], 2&lt;/code&gt; and then &lt;code&gt;a[0] += [3]&lt;/code&gt;, you might think we would have &lt;code&gt;a = [1, 3], 2&lt;/code&gt;, but in Python, tuples are not mutable, so we get an error. However, after the error, &lt;code&gt;a&lt;/code&gt; still evaluates as &lt;code&gt;([1, 3], 2)&lt;/code&gt;. Why does this happen? At the source level, it might look like if the &lt;code&gt;+=&lt;/code&gt; line threw an error, then its side effects wouldn&amp;rsquo;t happen. But, if we look at the bytecode representation (by using the &lt;code&gt;dis&lt;/code&gt; module), we see that is actually not the case.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
