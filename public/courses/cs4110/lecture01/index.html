<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lecture 1: Course Overview | Jiming Chen</title><meta name=keywords content><meta name=description content="This lecture serves as theater, e.g. to show why studying programming languages might be cool.
Programming Language Quirk Examples
One cool example of programming languages being weird is how [] + [], [] + {}, {} + [], and {} + {} all evaluate to different things in JavaScript.
If we run a = [1], 2 and then a[0] += [3], you might think we would have a = [1, 3], 2, but in Python, tuples are not mutable, so we get an error. However, after the error, a still evaluates as ([1, 3], 2). Why does this happen? At the source level, it might look like if the += line threw an error, then its side effects wouldn&rsquo;t happen. But, if we look at the bytecode representation (by using the dis module), we see that is actually not the case."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/courses/cs4110/lecture01/><link crossorigin=anonymous href=/assets/css/stylesheet.0788e016f920508aef4b1850b916d4a2a5a89167bb733638fd43d8d85a28d7f4.css integrity="sha256-B4jgFvkgUIrvSxhQuRbUoqWokWe7czY4/UPY2Foo1/Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/courses/cs4110/lecture01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/courses/cs4110/lecture01/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Lecture 1: Course Overview"><meta property="og:description" content="This lecture serves as theater, e.g. to show why studying programming languages might be cool.
Programming Language Quirk Examples One cool example of programming languages being weird is how [] + [], [] + {}, {} + [], and {} + {} all evaluate to different things in JavaScript.
If we run a = [1], 2 and then a[0] += [3], you might think we would have a = [1, 3], 2, but in Python, tuples are not mutable, so we get an error. However, after the error, a still evaluates as ([1, 3], 2). Why does this happen? At the source level, it might look like if the += line threw an error, then its side effects wouldn’t happen. But, if we look at the bytecode representation (by using the dis module), we see that is actually not the case."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="courses"><meta property="article:published_time" content="2025-08-25T10:08:42-04:00"><meta property="article:modified_time" content="2025-08-25T10:08:42-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture 1: Course Overview"><meta name=twitter:description content="This lecture serves as theater, e.g. to show why studying programming languages might be cool.
Programming Language Quirk Examples
One cool example of programming languages being weird is how [] + [], [] + {}, {} + [], and {} + {} all evaluate to different things in JavaScript.
If we run a = [1], 2 and then a[0] += [3], you might think we would have a = [1, 3], 2, but in Python, tuples are not mutable, so we get an error. However, after the error, a still evaluates as ([1, 3], 2). Why does this happen? At the source level, it might look like if the += line threw an error, then its side effects wouldn&rsquo;t happen. But, if we look at the bytecode representation (by using the dis module), we see that is actually not the case."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Course Notes","item":"https://jiming-chen.github.io/courses/"},{"@type":"ListItem","position":2,"name":"CS 4110: Programming Languages and Logics","item":"https://jiming-chen.github.io/courses/cs4110/"},{"@type":"ListItem","position":3,"name":"Lecture 1: Course Overview","item":"https://jiming-chen.github.io/courses/cs4110/lecture01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lecture 1: Course Overview","name":"Lecture 1: Course Overview","description":"This lecture serves as theater, e.g. to show why studying programming languages might be cool.\nProgramming Language Quirk Examples One cool example of programming languages being weird is how [] + [], [] + {}, {} + [], and {} + {} all evaluate to different things in JavaScript.\nIf we run a = [1], 2 and then a[0] += [3], you might think we would have a = [1, 3], 2, but in Python, tuples are not mutable, so we get an error. However, after the error, a still evaluates as ([1, 3], 2). Why does this happen? At the source level, it might look like if the += line threw an error, then its side effects wouldn\u0026rsquo;t happen. But, if we look at the bytecode representation (by using the dis module), we see that is actually not the case.\n","keywords":[],"articleBody":"This lecture serves as theater, e.g. to show why studying programming languages might be cool.\nProgramming Language Quirk Examples One cool example of programming languages being weird is how [] + [], [] + {}, {} + [], and {} + {} all evaluate to different things in JavaScript.\nIf we run a = [1], 2 and then a[0] += [3], you might think we would have a = [1, 3], 2, but in Python, tuples are not mutable, so we get an error. However, after the error, a still evaluates as ([1, 3], 2). Why does this happen? At the source level, it might look like if the += line threw an error, then its side effects wouldn’t happen. But, if we look at the bytecode representation (by using the dis module), we see that is actually not the case.\nIn Java, two researchers (Nada Amin and Ross Tate) realized that Java’s type system had gotten so complex that it no longer enforced type constraints as it was initially designed. They played with classes and methods in such a way so that any type could be cast to any other type (by taking advantage of the fact that subtypes can be cast up to their supertypes and by using wildcards without actually checking fot the existence of such the wildcard type). Ultimately, this allows 0 to be coerced to be a string and beat the compile-time type check but not the run-time type check.\nProgramming Language Design What makes a good programming language? One answer might be that it is one people use. But many people disagree that JavaScript is the best language. Some good features include the following:\nSimplicity Implementing things should not be confusing (some languages like Perl and Python have their primitives non-orthogonal meaning there are many ways to do things). Readability Code should be elegant and have intuitive syntax. Safety Rust doesn’t have an intermediate virtual machine like Java, but it still allows safe programming. Modularity This allows composition and collaboration. Efficiency It should be possible to write a good compiler so that code can actually run fast. Almost always, these criteria conflict.\nTypes usually restrict what types of programs you can write. Runtime checks eliminate errors, e.g. Python and Java can crash a program whereas C enters undefined behavior. But this has a cost and can affect efficiency. Some languages are nice for quick prototyping (Python) but may not be the best for long-term development (like OCaml might be better for). Therefore, a lot of work in programming language design goes into maximizing these benefits while minimizing those conflicts, and people have come up with fairly creative solutions to these problems.\nFormal Semantics What do programs mean, precisely? There are three classic approaches to this question.\nOperational semantics treats programs like mathematical objects, which we can model and mathematically prove things about on an abstract machine. This is useful for implementing compilers and interpreters. Think finite automata and Turing machines. Start diggin in yo program twin.\nOthers like Dijkstra and David Gries model programs by the logical formulas they obey. This is called axiomatic semantics and is similar to preconditions, postconditions, and invariants that are often taught in introductory programming classes. Separation logic, which uses axiomatic semantics, is relatively new and is being adopted by big tech companies who write large verifiers.\nDenotational semantics models programs literally as mathematical objects, like functions. This is helpful especially in functional programming, as it can help us think about composition as well as when things are expressable or equivalent. Professor Foster works in domain-specific languages, where denotational semantics is useful.\nWhile these are all separate approaches, they generally agree. Additionally, these approaches come up in linguistics and NLP as well.\nInterestingly, few languages have a formal semantics. JavaScript had a formal semantics imposed on it decades after it became mainstream. WebAssembly had it from the set. At Cambridge, they’re trying to create formal semantics for instruction set architectures.\nThis is important because we want to know what our code means, especially if code controls our planes, money, etc. Also related is that we want verification of code, and to verify code, it helps to know what the code should even do to begin with.\nBut why don’t many languages have formal semantics? In reality, programming languages can get very complex and dense, and this may not be feasible, but formal semantics is still important. There is often pressure to “add things in” when designing languages, and we need to be sure that new features don’t break old features (which is what happened when Java added generics and wildcards).\nOne interest in AI/program synthesis is constraining code that LLMs generate to be safe since they are trained on code that may not necessarily be safe.\n","wordCount":"797","inLanguage":"en","datePublished":"2025-08-25T10:08:42-04:00","dateModified":"2025-08-25T10:08:42-04:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/courses/cs4110/lecture01/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lecture 1: Course Overview</h1><div class=post-meta><span title='2025-08-25 10:08:42 -0400 EDT'>August 25, 2025</span>&nbsp;·&nbsp;Jiming Chen</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#programming-language-quirk-examples>Programming Language Quirk Examples</a></li><li><a href=#programming-language-design>Programming Language Design</a></li><li><a href=#formal-semantics>Formal Semantics</a></li></ul></nav></div></details></div><div class=post-content><p>This lecture serves as theater, e.g. to show why studying programming languages might be cool.</p><h2 id=programming-language-quirk-examples>Programming Language Quirk Examples<a hidden class=anchor aria-hidden=true href=#programming-language-quirk-examples>#</a></h2><p>One cool example of programming languages being weird is how <code>[] + []</code>, <code>[] + {}</code>, <code>{} + []</code>, and <code>{} + {}</code> all evaluate to different things in JavaScript.</p><p>If we run <code>a = [1], 2</code> and then <code>a[0] += [3]</code>, you might think we would have <code>a = [1, 3], 2</code>, but in Python, tuples are not mutable, so we get an error. However, after the error, <code>a</code> still evaluates as <code>([1, 3], 2)</code>. Why does this happen? At the source level, it might look like if the <code>+=</code> line threw an error, then its side effects wouldn&rsquo;t happen. But, if we look at the bytecode representation (by using the <code>dis</code> module), we see that is actually not the case.</p><p>In Java, two researchers (Nada Amin and Ross Tate) realized that Java&rsquo;s type system had gotten so complex that it no longer enforced type constraints as it was initially designed. They played with classes and methods in such a way so that any type could be cast to any other type (by taking advantage of the fact that subtypes can be cast up to their supertypes and by using wildcards without actually checking fot the existence of such the wildcard type). Ultimately, this allows <code>0</code> to be coerced to be a string and beat the compile-time type check but not the run-time type check.</p><h2 id=programming-language-design>Programming Language Design<a hidden class=anchor aria-hidden=true href=#programming-language-design>#</a></h2><p>What makes a good programming language? One answer might be that it is one people use. But many people disagree that JavaScript is the best language. Some good features include the following:</p><ul><li>Simplicity<ul><li>Implementing things should not be confusing (some languages like Perl and Python have their primitives non-orthogonal meaning there are many ways to do things).</li></ul></li><li>Readability<ul><li>Code should be elegant and have intuitive syntax.</li></ul></li><li>Safety<ul><li>Rust doesn&rsquo;t have an intermediate virtual machine like Java, but it still allows safe programming.</li></ul></li><li>Modularity<ul><li>This allows composition and collaboration.</li></ul></li><li>Efficiency<ul><li>It should be possible to write a good compiler so that code can actually run fast.</li></ul></li></ul><p>Almost always, these criteria conflict.</p><ul><li>Types usually restrict what types of programs you can write.</li><li>Runtime checks eliminate errors, e.g. Python and Java can crash a program whereas C enters undefined behavior. But this has a cost and can affect efficiency.</li><li>Some languages are nice for quick prototyping (Python) but may not be the best for long-term development (like OCaml might be better for).</li></ul><p>Therefore, a lot of work in programming language design goes into maximizing these benefits while minimizing those conflicts, and people have come up with fairly creative solutions to these problems.</p><h2 id=formal-semantics>Formal Semantics<a hidden class=anchor aria-hidden=true href=#formal-semantics>#</a></h2><p>What do programs mean, precisely? There are three classic approaches to this question.</p><p>Operational semantics treats programs like mathematical objects, which we can model and mathematically prove things about on an abstract machine. This is useful for implementing compilers and interpreters. Think finite automata and Turing machines. Start diggin in yo program twin.</p><p>Others like Dijkstra and David Gries model programs by the logical formulas they obey. This is called axiomatic semantics and is similar to preconditions, postconditions, and invariants that are often taught in introductory programming classes. Separation logic, which uses axiomatic semantics, is relatively new and is being adopted by big tech companies who write large verifiers.</p><p>Denotational semantics models programs literally as mathematical objects, like functions. This is helpful especially in functional programming, as it can help us think about composition as well as when things are expressable or equivalent. Professor Foster works in domain-specific languages, where denotational semantics is useful.</p><p>While these are all separate approaches, they generally agree. Additionally, these approaches come up in linguistics and NLP as well.</p><p>Interestingly, few languages have a formal semantics. JavaScript had a formal semantics imposed on it decades after it became mainstream. WebAssembly had it from the set. At Cambridge, they&rsquo;re trying to create formal semantics for instruction set architectures.</p><p>This is important because we want to know what our code means, especially if code controls our planes, money, etc. Also related is that we want verification of code, and to verify code, it helps to know what the code should even do to begin with.</p><p>But why don&rsquo;t many languages have formal semantics? In reality, programming languages can get very complex and dense, and this may not be feasible, but formal semantics is still important. There is often pressure to &ldquo;add things in&rdquo; when designing languages, and we need to be sure that new features don&rsquo;t break old features (which is what happened when Java added generics and wildcards).</p><p>One interest in AI/program synthesis is constraining code that LLMs generate to be safe since they are trained on code that may not necessarily be safe.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>