<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimal Theme Park Ride Order | Jiming Chen</title>
<meta name=keywords content><meta name=description content="If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? This app (also embedded below) seeks to do exactly that.
Here is the Github link.
Demo

Motivation
There is a lot of information we can work with:

Each ride has an associated happiness.
Each ride has a wait time.
Total time must not exceed the time the park is open.
Walking between any two rides takes a certain amount of time.
Throughout the day, wait times and walk times (crowd levels) change.

My first thought was to use a maximum flow reduction with Ford-Fulkerson. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible."><meta name=author content="Jiming Chen"><link rel=canonical href=https://jiming-chen.github.io/projects/rides/><link crossorigin=anonymous href=/assets/css/stylesheet.862d2ab5d22734725b747026f6cbcd72cf56acbcb80e88f95d22ca71d767e619.css integrity="sha256-hi0qtdInNHJbdHAm9svNcs9WrLy4Doj5XSLKcddn5hk=" rel="preload stylesheet" as=style><link rel=icon href=https://jiming-chen.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiming-chen.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jiming-chen.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://jiming-chen.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://jiming-chen.github.io/%3C/icons/apple-touch-icon.png%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jiming-chen.github.io/projects/rides/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KTD621L9T6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KTD621L9T6")</script><meta property="og:url" content="https://jiming-chen.github.io/projects/rides/"><meta property="og:site_name" content="Jiming Chen"><meta property="og:title" content="Optimal Theme Park Ride Order"><meta property="og:description" content="If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? This app (also embedded below) seeks to do exactly that.
Here is the Github link.
Demo Motivation There is a lot of information we can work with:
Each ride has an associated happiness. Each ride has a wait time. Total time must not exceed the time the park is open. Walking between any two rides takes a certain amount of time. Throughout the day, wait times and walk times (crowd levels) change. My first thought was to use a maximum flow reduction with Ford-Fulkerson. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2025-01-14T01:59:49-08:00"><meta property="article:modified_time" content="2025-01-14T01:59:49-08:00"><meta property="og:image" content="https://jiming-chen.github.io/projects/rides/magic_kingdom.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jiming-chen.github.io/projects/rides/magic_kingdom.png"><meta name=twitter:title content="Optimal Theme Park Ride Order"><meta name=twitter:description content="If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? This app (also embedded below) seeks to do exactly that.
Here is the Github link.
Demo

Motivation
There is a lot of information we can work with:

Each ride has an associated happiness.
Each ride has a wait time.
Total time must not exceed the time the park is open.
Walking between any two rides takes a certain amount of time.
Throughout the day, wait times and walk times (crowd levels) change.

My first thought was to use a maximum flow reduction with Ford-Fulkerson. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://jiming-chen.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Optimal Theme Park Ride Order","item":"https://jiming-chen.github.io/projects/rides/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimal Theme Park Ride Order","name":"Optimal Theme Park Ride Order","description":"If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? This app (also embedded below) seeks to do exactly that.\nHere is the Github link.\nDemo Motivation There is a lot of information we can work with:\nEach ride has an associated happiness. Each ride has a wait time. Total time must not exceed the time the park is open. Walking between any two rides takes a certain amount of time. Throughout the day, wait times and walk times (crowd levels) change. My first thought was to use a maximum flow reduction with Ford-Fulkerson. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible.\n","keywords":[],"articleBody":"If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? This app (also embedded below) seeks to do exactly that.\nHere is the Github link.\nDemo Motivation There is a lot of information we can work with:\nEach ride has an associated happiness. Each ride has a wait time. Total time must not exceed the time the park is open. Walking between any two rides takes a certain amount of time. Throughout the day, wait times and walk times (crowd levels) change. My first thought was to use a maximum flow reduction with Ford-Fulkerson. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible.\nDesign Instead, I opted for a greedy solution: say you assign a rating to each ride. At any point for any ride, you know the its wait time as well as how long it will take to get to it. Call the sum of those two times the cost to ride that ride. Then, we can calculate its happiness per cost and repeatedly choose the ride with the greatest happiness per cost.\nAlthough not necessarily optimal, this algorithm ended up being very easy to implement. For example, I thought that estimating distances between rides would be hard and not generalizable to other parks. However, the API I used for wait times conveniently included rides already sectioned into lands, meaning I could assign short walk times to rides in the same or adjacent lands and longer walk times to rides in non-adjacent lands.\nAdditionally, this greedy algorithm is similar to judgments people actually make in the park, but it allows us to have better information, which makes it appealing.\nFor practicality reasons, I wanted to be able to use this app outside of park hours, which was when live data was available on the API, so I scraped average wait times and approximately adjusted based on a wait time vs. time of day graph I saw for Magic Kingdom.\nThis allowed two modes: a pre-park planning mode and an in-park planning mode. The pre-park mode gives an entire day’s ride itinerary based on estimations of wait times (which hopefully account for crowd level changes). The in-park planning mode uses live wait time data although I am currently working on letting it recommend based on already ridden rides.\n","wordCount":"411","inLanguage":"en","image":"https://jiming-chen.github.io/projects/rides/magic_kingdom.png","datePublished":"2025-01-14T01:59:49-08:00","dateModified":"2025-01-14T01:59:49-08:00","author":{"@type":"Person","name":"Jiming Chen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiming-chen.github.io/projects/rides/"},"publisher":{"@type":"Organization","name":"Jiming Chen","logo":{"@type":"ImageObject","url":"https://jiming-chen.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiming-chen.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiming-chen.github.io/icons/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiming-chen.github.io/about title="About Me"><span>About Me</span></a></li><li><a href=https://jiming-chen.github.io/projects/ title=Portfolio><span>Portfolio</span></a></li><li><a href=https://jiming-chen.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jiming-chen.github.io/courses/ title="Course Notes"><span>Course Notes</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Optimal Theme Park Ride Order</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#demo>Demo</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#design>Design</a></li></ul></nav></div></details></div><div class=post-content><p>If we assign happiness to certain rides and have information about how much time it takes to ride a string of rides in a certain order, how can we maximize happiness in one day at a theme park? <a href=https://jjc256.github.io/rides/ rel=noopener target=_blank>This app</a> (also embedded below) seeks to do exactly that.</p><p><a href=https://github.com/jjc256/rides rel=noopener target=_blank>Here</a> is the Github link.</p><h2 id=demo>Demo<a hidden class=anchor aria-hidden=true href=#demo>#</a></h2><iframe src=https://jjc256.github.io/rides/ width=100% height=600px></iframe><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><p>There is a lot of information we can work with:</p><ul><li>Each ride has an associated happiness.</li><li>Each ride has a wait time.</li><li>Total time must not exceed the time the park is open.</li><li>Walking between any two rides takes a certain amount of time.</li><li>Throughout the day, wait times and walk times (crowd levels) change.</li></ul><p>My first thought was to use a maximum flow reduction with <a href=https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm rel=noopener target=_blank>Ford-Fulkerson</a>. However, there seemed to be too many factors which made Ford-Fulkerson seem infeasible.</p><h2 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h2><p>Instead, I opted for a greedy solution: say you assign a rating to each ride. At any point for any ride, you know the its wait time as well as how long it will take to get to it. Call the sum of those two times the cost to ride that ride. Then, we can calculate its happiness per cost and repeatedly choose the ride with the greatest happiness per cost.</p><p>Although not necessarily optimal, this algorithm ended up being very easy to implement. For example, I thought that estimating distances between rides would be hard and not generalizable to other parks. However, the API I used for wait times conveniently included rides already sectioned into lands, meaning I could assign short walk times to rides in the same or adjacent lands and longer walk times to rides in non-adjacent lands.</p><p>Additionally, this greedy algorithm is similar to judgments people actually make in the park, but it allows us to have better information, which makes it appealing.</p><p>For practicality reasons, I wanted to be able to use this app outside of park hours, which was when live data was available on the API, so I scraped average wait times and approximately adjusted based on a wait time vs. time of day graph I saw for Magic Kingdom.</p><p>This allowed two modes: a pre-park planning mode and an in-park planning mode. The pre-park mode gives an entire day&rsquo;s ride itinerary based on estimations of wait times (which hopefully account for crowd level changes). The in-park planning mode uses live wait time data although I am currently working on letting it recommend based on already ridden rides.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jiming-chen.github.io/>Jiming Chen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>